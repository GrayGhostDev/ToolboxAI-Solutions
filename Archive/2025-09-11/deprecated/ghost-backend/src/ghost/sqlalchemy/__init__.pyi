# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportUnusedFunction=false
"""Permissive, static-only stub for SQLAlchemy used by GhostBackend.
This file intentionally uses Any and minimal signatures to reduce static
analysis noise without changing runtime behaviour.
"""
# Add Iterator and overload imports; keep permissive typing
from typing import (
    Any,
    Awaitable,
    Generator,
    Generic,
    Iterator,
    List,
    Optional,
    TypeVar,
    overload,
)

T = TypeVar("T")

declared_attr: Any
# Basic aliases and permissive implementations used by the analyzer
T = TypeVar("T")

# Keep runtime aliases permissive but provide descriptor shapes below so
# the analyzer understands class-vs-instance access patterns.
Column: Any
Relationship: Any
relationship: Any
declared_attr: Any
select: Any
func: Any

class ColumnElement(Generic[T]):
    # Make truthiness explicit so conditionals like `if Model.x:` type-check.
    def __bool__(self) -> bool: ...
    def __clause_element__(self) -> "ColumnElement[T]": ...

class Mapped(Generic[T]):
    @overload
    def __get__(self, obj: None, objtype: type | None = None) -> "ColumnElement[T]": ...
    @overload
    def __get__(self, obj: object, objtype: type | None = None) -> T: ...
    def __get__(self, obj: object | None, objtype: type | None = None): ...
    def __set__(self, obj: object | None, value: Any) -> None: ...
    def __delete__(self, obj: object | None) -> None: ...

class Query(Generic[T]):
    def filter(self, *args: Any, **kwargs: Any) -> "Query[T]": ...
    def filter_by(self, *args: Any, **kwargs: Any) -> "Query[T]": ...
    def all(self) -> List[T]: ...
    def first(self) -> Optional[T]: ...
    def one(self) -> T: ...

class ScalarResult(Generic[T]):
    def all(self) -> List[T]: ...
    def first(self) -> Optional[T]: ...
    def one(self) -> T: ...

class Result(Generic[T], Awaitable[T]):
    def scalars(self, *args: Any, **kwargs: Any) -> ScalarResult[T]: ...
    def one(self, *args: Any, **kwargs: Any) -> T: ...
    def first(self, *args: Any, **kwargs: Any) -> Optional[T]: ...
    def __await__(self) -> Generator[Any, None, T]: ...
    def __iter__(self) -> Iterator[T]: ...

class Session:
    def execute(self, *args: Any, **kwargs: Any) -> Result[Any]: ...
    def query(self, *args: Any, **kwargs: Any) -> Query[Any]: ...
    def scalar_one(self, *args: Any, **kwargs: Any) -> Any: ...
    def scalar_one_or_none(self, *args: Any, **kwargs: Any) -> Optional[Any]: ...

class AsyncSession:
    async def execute(self, *args: Any, **kwargs: Any) -> Result[Any]: ...
    def query(self, *args: Any, **kwargs: Any) -> Query[Any]: ...
    async def scalar_one(self, *args: Any, **kwargs: Any) -> Any: ...
    async def scalar_one_or_none(self, *args: Any, **kwargs: Any) -> Optional[Any]: ...
