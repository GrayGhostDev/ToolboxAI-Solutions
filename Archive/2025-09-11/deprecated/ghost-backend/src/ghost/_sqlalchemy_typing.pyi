# pyright: reportUnusedVariable=false, reportUnusedImport=false, reportUnusedFunction=false
from typing import (
    Any,
    Awaitable,
    Generator,
    Generic,
    Iterator,
    List,
    Optional,
    TypeVar,
    overload,
)

# Minimal static-only typing helpers for pyright to recognize Column/Mapping
# descriptors, Session/AsyncSession and Query/Result shapes used in the project.

T = TypeVar("T")

class ColumnElement(Generic[T]):
    # SQLAlchemy column/expressions implement clause element hooks used by
    # filter()/and_/or_. Provide a permissive view for the analyzer.
    # Treat __bool__ as returning bool to allow conditional checks like `if Model.x:`
    def __bool__(self) -> bool: ...
    def __clause_element__(self) -> "ColumnElement[T]": ...
    # SQLAlchemy column elements may be used where a raw python value is
    # expected in application code; make them permissively compatible via
    # a __clause_element__ hook and truthiness defined above.
    def __repr__(self) -> str: ...

class Mapped(Generic[T]):
    # Descriptor protocol: when read from the class returns a ColumnElement[T]
    # so `Model.id` resolves to a Column-like expression; when read from an
    # instance return the python type T.
    @overload
    def __get__(self, obj: None, objtype: type | None = None) -> "ColumnElement[T]": ...
    @overload
    def __get__(self, obj: object, objtype: type | None = None) -> T: ...
    def __get__(self, obj: object | None, objtype: type | None = None): ...
    def __set__(self, obj: object, value: Any) -> None: ...
    def __delete__(self, obj: object) -> None: ...
    # Support SQLAlchemy descriptor protocols
    def __clause_element__(self) -> "ColumnElement[T]": ...

class ORMDescriptor(Generic[T]):
    @overload
    def __get__(self, obj: None, objtype: type | None = None) -> "ColumnElement[T]": ...
    @overload
    def __get__(self, obj: object, objtype: type | None = None) -> T: ...
    def __get__(self, obj: object | None, objtype: type | None = None): ...

class SQLCoreOperations(Generic[T]):
    pass

class Column(ColumnElement[T], Mapped[T], Generic[T]):
    def __new__(cls, *args: Any, **kwargs: Any) -> "Column[T]": ...
    # Delegate truthiness to ColumnElement.__bool__
    def __bool__(self) -> bool: ...
    def __clause_element__(self) -> "ColumnElement[T]": ...

class Query(Generic[T]):
    def filter(self, *args: Any, **kwargs: Any) -> "Query[T]": ...
    def filter_by(self, *args: Any, **kwargs: Any) -> "Query[T]": ...
    def all(self, *args: Any, **kwargs: Any) -> List[T]: ...
    def first(self, *args: Any, **kwargs: Any) -> Optional[T]: ...
    def one(self, *args: Any, **kwargs: Any) -> T: ...
    def scalar_one(self, *args: Any, **kwargs: Any) -> T: ...
    def scalar_one_or_none(self, *args: Any, **kwargs: Any) -> Optional[T]: ...

class ScalarResult(Generic[T]):
    def all(self) -> List[T]: ...
    def first(self) -> Optional[T]: ...
    def one(self) -> T: ...

class Result(Generic[T], Awaitable[T]):
    # scalars() in SQLAlchemy returns a ScalarResult-like object which
    # provides scalar-specific helpers. Expose a permissive static view.
    def scalars(self, *args: Any, **kwargs: Any) -> ScalarResult[T]: ...
    def one(self, *args: Any, **kwargs: Any) -> T: ...
    def first(self, *args: Any, **kwargs: Any) -> Optional[T]: ...
    # Make Result awaitable for `await session.execute(...)` patterns.
    def __await__(self) -> Generator[Any, None, T]: ...
    # Also support iteration/async-style uses in some call sites
    def __iter__(self) -> Iterator[T]: ...

# declared_attr and Relationship are often used as decorators/constructors
# that return descriptors; model code assigns their result to class attrs.
declared_attr: Any
Relationship: Any

class Session:
    def query(self, *args: Any, **kwargs: Any) -> Query[Any]: ...
    # execute may be awaited by the caller in some async wrappers; return a Result
    def execute(self, *args: Any, **kwargs: Any) -> Result[Any]: ...
    def scalar_one(self, *args: Any, **kwargs: Any) -> Any: ...
    def scalar_one_or_none(self, *args: Any, **kwargs: Any) -> Optional[Any]: ...
    def add(self, *args: Any, **kwargs: Any) -> None: ...
    def commit(self, *args: Any, **kwargs: Any) -> None: ...
    def rollback(self, *args: Any, **kwargs: Any) -> None: ...

class AsyncSession:
    async def execute(self, *args: Any, **kwargs: Any) -> Result[Any]: ...
    def query(self, *args: Any, **kwargs: Any) -> Query[Any]: ...
    async def scalar_one(self, *args: Any, **kwargs: Any) -> Any: ...
    async def scalar_one_or_none(self, *args: Any, **kwargs: Any) -> Optional[Any]: ...
    async def commit(self, *args: Any, **kwargs: Any) -> None: ...
    async def rollback(self, *args: Any, **kwargs: Any) -> None: ...

# Expose common helpers as Any to avoid strict runtime coupling in stubs
select: Any
func: Any
