"""
Vulnerability Scanner Agent - Scans for security vulnerabilities
Performs container scanning, dependency checking, and CVE detection
"""

import json
import logging
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any

import requests

from core.agents.base_agent import BaseAgent

logger = logging.getLogger(__name__)


class VulnerabilityScannerAgent(BaseAgent):
    """
    Specialized agent for scanning and detecting security vulnerabilities
    Integrates with vulnerability databases and scanning tools
    """

    def __init__(self):
        """Initialize the Vulnerability Scanner Agent"""
        super().__init__(
            name="VulnerabilityScannerAgent",
            description="Scans for security vulnerabilities in code, dependencies, and containers"
        )

        # CVE database API (using NIST NVD)
        self.nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        # Severity mapping
        self.severity_scores = {
            'critical': 9.0,
            'high': 7.0,
            'medium': 4.0,
            'low': 0.1
        }

        # Scan results cache
        self._scan_cache = {}
        self._cache_expiry = {}

    async def execute(self, task: dict[str, Any]) -> dict[str, Any]:
        """
        Execute vulnerability scanning using SPARC framework

        Args:
            task: Scanning task with target and parameters

        Returns:
            Scan results with vulnerabilities and recommendations
        """
        # Situation: Analyze scan requirements
        situation = self._analyze_situation(task)

        # Problem: Identify vulnerability risks
        problem = self._identify_problem(situation)

        # Alternatives: Evaluate scanning methods
        alternatives = self._evaluate_alternatives(problem)

        # Recommendation: Select scanning strategy
        recommendation = self._make_recommendation(alternatives)

        # Conclusion: Execute scan
        result = await self._execute_recommendation(recommendation, task)

        return result

    def _analyze_situation(self, task: dict[str, Any]) -> dict[str, Any]:
        """Analyze scanning requirements"""
        scan_type = task.get('scan_type', 'comprehensive')
        target_type = task.get('target_type', 'application')

        situation = {
            'scan_type': scan_type,
            'target_type': target_type,
            'environment': task.get('environment', 'development'),
            'include_dependencies': task.get('include_dependencies', True),
            'include_containers': task.get('include_containers', True),
            'severity_threshold': task.get('severity_threshold', 'medium'),
            'timestamp': datetime.utcnow().isoformat()
        }

        logger.info(f"Starting vulnerability scan: {scan_type} for {target_type}")
        return situation

    def _identify_problem(self, situation: dict[str, Any]) -> dict[str, Any]:
        """Identify potential vulnerability categories"""
        vulnerability_categories = []

        if situation['include_dependencies']:
            vulnerability_categories.append('dependency_vulnerabilities')

        if situation['include_containers']:
            vulnerability_categories.append('container_vulnerabilities')

        if situation['scan_type'] == 'comprehensive':
            vulnerability_categories.extend([
                'code_vulnerabilities',
                'configuration_vulnerabilities',
                'infrastructure_vulnerabilities'
            ])

        return {
            'categories': vulnerability_categories,
            'risk_level': 'high' if situation['environment'] == 'production' else 'medium',
            'scan_priority': self._determine_scan_priority(situation)
        }

    def _evaluate_alternatives(self, problem: dict[str, Any]) -> list[dict[str, Any]]:
        """Evaluate scanning alternatives"""
        alternatives = []

        if 'dependency_vulnerabilities' in problem['categories']:
            alternatives.append({
                'method': 'dependency_scan',
                'priority': 1,
                'tools': ['pip-audit', 'npm-audit', 'safety']
            })

        if 'container_vulnerabilities' in problem['categories']:
            alternatives.append({
                'method': 'container_scan',
                'priority': 2,
                'tools': ['trivy', 'clair', 'anchore']
            })

        if 'code_vulnerabilities' in problem['categories']:
            alternatives.append({
                'method': 'static_analysis',
                'priority': 3,
                'tools': ['bandit', 'semgrep', 'sonarqube']
            })

        return alternatives

    def _make_recommendation(self, alternatives: list[dict[str, Any]]) -> dict[str, Any]:
        """Recommend scanning strategy"""
        return {
            'strategy': 'layered_scanning',
            'methods': sorted(alternatives, key=lambda x: x['priority']),
            'parallel_execution': len(alternatives) > 2
        }

    async def _execute_recommendation(self, recommendation: dict[str, Any], task: dict[str, Any]) -> dict[str, Any]:
        """Execute vulnerability scan"""
        action = task.get('action', 'comprehensive_scan')

        try:
            if action == 'comprehensive_scan':
                return await self._comprehensive_scan(task)
            elif action == 'dependency_scan':
                return await self._scan_dependencies(task)
            elif action == 'container_scan':
                return await self._scan_containers(task)
            elif action == 'code_scan':
                return await self._scan_code(task)
            elif action == 'check_cve':
                return await self._check_cve(task)
            elif action == 'generate_report':
                return await self._generate_vulnerability_report(task)
            else:
                return {
                    'status': 'error',
                    'message': f'Unknown scan action: {action}'
                }
        except Exception as e:
            logger.error(f"Scan error: {str(e)}")
            return {
                'status': 'error',
                'message': str(e)
            }

    async def _comprehensive_scan(self, task: dict[str, Any]) -> dict[str, Any]:
        """Perform comprehensive vulnerability scan"""
        scan_results = {
            'timestamp': datetime.utcnow().isoformat(),
            'environment': task.get('environment', 'development'),
            'vulnerabilities': {
                'critical': [],
                'high': [],
                'medium': [],
                'low': []
            },
            'summary': {},
            'recommendations': []
        }

        # 1. Dependency scan
        dep_result = await self._scan_dependencies(task)
        if dep_result['status'] == 'success':
            for vuln in dep_result.get('vulnerabilities', []):
                severity = vuln.get('severity', 'medium').lower()
                if severity in scan_results['vulnerabilities']:
                    scan_results['vulnerabilities'][severity].append(vuln)

        # 2. Container scan
        container_result = await self._scan_containers(task)
        if container_result['status'] == 'success':
            for vuln in container_result.get('vulnerabilities', []):
                severity = vuln.get('severity', 'medium').lower()
                if severity in scan_results['vulnerabilities']:
                    scan_results['vulnerabilities'][severity].append(vuln)

        # 3. Code scan
        code_result = await self._scan_code(task)
        if code_result['status'] == 'success':
            for vuln in code_result.get('vulnerabilities', []):
                severity = vuln.get('severity', 'medium').lower()
                if severity in scan_results['vulnerabilities']:
                    scan_results['vulnerabilities'][severity].append(vuln)

        # Generate summary
        scan_results['summary'] = {
            'total_vulnerabilities': sum(len(vulns) for vulns in scan_results['vulnerabilities'].values()),
            'critical_count': len(scan_results['vulnerabilities']['critical']),
            'high_count': len(scan_results['vulnerabilities']['high']),
            'medium_count': len(scan_results['vulnerabilities']['medium']),
            'low_count': len(scan_results['vulnerabilities']['low'])
        }

        # Generate recommendations
        scan_results['recommendations'] = self._generate_recommendations(scan_results)

        # Calculate CVSS score
        scan_results['cvss_score'] = self._calculate_cvss_score(scan_results)

        return {
            'status': 'success',
            'scan_results': scan_results
        }

    async def _scan_dependencies(self, task: dict[str, Any]) -> dict[str, Any]:
        """Scan dependencies for known vulnerabilities"""
        vulnerabilities = []

        # Python dependencies
        if Path('requirements.txt').exists() or Path('Pipfile').exists():
            python_vulns = await self._scan_python_dependencies()
            vulnerabilities.extend(python_vulns)

        # Node.js dependencies
        if Path('package.json').exists():
            nodejs_vulns = await self._scan_nodejs_dependencies()
            vulnerabilities.extend(nodejs_vulns)

        # Ruby dependencies
        if Path('Gemfile').exists():
            ruby_vulns = await self._scan_ruby_dependencies()
            vulnerabilities.extend(ruby_vulns)

        # Java dependencies
        if Path('pom.xml').exists() or Path('build.gradle').exists():
            java_vulns = await self._scan_java_dependencies()
            vulnerabilities.extend(java_vulns)

        return {
            'status': 'success',
            'vulnerabilities': vulnerabilities,
            'total': len(vulnerabilities)
        }

    async def _scan_python_dependencies(self) -> list[dict[str, Any]]:
        """Scan Python dependencies"""
        vulnerabilities = []

        try:
            # Try pip-audit first
            result = subprocess.run(
                ['pip-audit', '--format', 'json'],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                audit_data = json.loads(result.stdout)
                for vuln in audit_data.get('vulnerabilities', []):
                    vulnerabilities.append({
                        'type': 'dependency',
                        'language': 'python',
                        'package': vuln.get('name'),
                        'version': vuln.get('version'),
                        'vulnerability': vuln.get('id'),
                        'severity': self._map_severity(vuln.get('severity', 'UNKNOWN')),
                        'description': vuln.get('description'),
                        'fix_version': vuln.get('fix_versions', [None])[0]
                    })
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            # Fallback to safety if pip-audit not available
            try:
                result = subprocess.run(
                    ['safety', 'check', '--json'],
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                if result.returncode == 0:
                    safety_data = json.loads(result.stdout)
                    for vuln in safety_data:
                        vulnerabilities.append({
                            'type': 'dependency',
                            'language': 'python',
                            'package': vuln.get('package'),
                            'version': vuln.get('installed_version'),
                            'vulnerability': vuln.get('vulnerability'),
                            'severity': 'high',  # Safety doesn't provide severity
                            'description': vuln.get('description'),
                            'fix_version': vuln.get('affected_versions')
                        })
            except:
                logger.warning("Python vulnerability scanning tools not available")

        return vulnerabilities

    async def _scan_nodejs_dependencies(self) -> list[dict[str, Any]]:
        """Scan Node.js dependencies"""
        vulnerabilities = []

        try:
            # Use npm audit
            result = subprocess.run(
                ['npm', 'audit', '--json'],
                capture_output=True,
                text=True,
                timeout=60,
                cwd='apps/dashboard'  # Scan dashboard directory
            )

            audit_data = json.loads(result.stdout)

            if 'vulnerabilities' in audit_data:
                for pkg_name, vuln_data in audit_data['vulnerabilities'].items():
                    for vuln in vuln_data.get('via', []):
                        if isinstance(vuln, dict):
                            vulnerabilities.append({
                                'type': 'dependency',
                                'language': 'javascript',
                                'package': pkg_name,
                                'version': vuln_data.get('version'),
                                'vulnerability': vuln.get('source', 'Unknown'),
                                'severity': vuln.get('severity', 'medium'),
                                'description': vuln.get('title'),
                                'fix_version': vuln_data.get('fixAvailable', {}).get('version')
                            })
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            logger.warning("npm audit not available")
        except Exception as e:
            logger.error(f"Error scanning Node.js dependencies: {e}")

        return vulnerabilities

    async def _scan_ruby_dependencies(self) -> list[dict[str, Any]]:
        """Scan Ruby dependencies"""
        vulnerabilities = []

        try:
            # Use bundle-audit
            result = subprocess.run(
                ['bundle-audit', 'check', '--format', 'json'],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                audit_data = json.loads(result.stdout)
                for vuln in audit_data.get('vulnerabilities', []):
                    vulnerabilities.append({
                        'type': 'dependency',
                        'language': 'ruby',
                        'package': vuln.get('gem'),
                        'version': vuln.get('version'),
                        'vulnerability': vuln.get('cve'),
                        'severity': self._map_severity(vuln.get('criticality', 'medium')),
                        'description': vuln.get('title'),
                        'fix_version': vuln.get('patched_versions')
                    })
        except:
            logger.warning("Ruby vulnerability scanning not available")

        return vulnerabilities

    async def _scan_java_dependencies(self) -> list[dict[str, Any]]:
        """Scan Java dependencies"""
        vulnerabilities = []

        # Would use OWASP Dependency Check or similar
        # Simplified implementation

        return vulnerabilities

    async def _scan_containers(self, task: dict[str, Any]) -> dict[str, Any]:
        """Scan container images for vulnerabilities"""
        vulnerabilities = []

        # Get list of Docker images
        try:
            result = subprocess.run(
                ['docker', 'images', '--format', '{{.Repository}}:{{.Tag}}'],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                images = result.stdout.strip().split('\n')

                for image in images:
                    if image and image != '<none>:<none>':
                        # Scan each image with Trivy (if available)
                        image_vulns = await self._scan_docker_image(image)
                        vulnerabilities.extend(image_vulns)
        except:
            logger.warning("Docker not available for container scanning")

        # Also scan Kubernetes deployments if configured
        if task.get('scan_kubernetes', False):
            k8s_vulns = await self._scan_kubernetes_deployments()
            vulnerabilities.extend(k8s_vulns)

        return {
            'status': 'success',
            'vulnerabilities': vulnerabilities,
            'total': len(vulnerabilities)
        }

    async def _scan_docker_image(self, image: str) -> list[dict[str, Any]]:
        """Scan a single Docker image"""
        vulnerabilities = []

        try:
            # Use Trivy for container scanning
            result = subprocess.run(
                ['trivy', 'image', '--format', 'json', '--quiet', image],
                capture_output=True,
                text=True,
                timeout=120
            )

            if result.returncode == 0:
                trivy_data = json.loads(result.stdout)

                for result_item in trivy_data.get('Results', []):
                    for vuln in result_item.get('Vulnerabilities', []):
                        vulnerabilities.append({
                            'type': 'container',
                            'image': image,
                            'package': vuln.get('PkgName'),
                            'version': vuln.get('InstalledVersion'),
                            'vulnerability': vuln.get('VulnerabilityID'),
                            'severity': vuln.get('Severity', 'UNKNOWN').lower(),
                            'description': vuln.get('Description'),
                            'fix_version': vuln.get('FixedVersion'),
                            'layer': result_item.get('Target')
                        })
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            logger.warning(f"Trivy not available for scanning {image}")
        except Exception as e:
            logger.error(f"Error scanning Docker image {image}: {e}")

        return vulnerabilities

    async def _scan_kubernetes_deployments(self) -> list[dict[str, Any]]:
        """Scan Kubernetes deployments for vulnerabilities"""
        vulnerabilities = []

        # Would integrate with Kubernetes API to scan running pods
        # Simplified implementation

        return vulnerabilities

    async def _scan_code(self, task: dict[str, Any]) -> dict[str, Any]:
        """Scan source code for security vulnerabilities"""
        vulnerabilities = []

        # Python code scanning with Bandit
        if task.get('scan_python_code', True):
            python_vulns = await self._scan_python_code()
            vulnerabilities.extend(python_vulns)

        # JavaScript code scanning
        if task.get('scan_javascript_code', True):
            js_vulns = await self._scan_javascript_code()
            vulnerabilities.extend(js_vulns)

        # General pattern scanning with Semgrep
        if task.get('use_semgrep', True):
            semgrep_vulns = await self._scan_with_semgrep()
            vulnerabilities.extend(semgrep_vulns)

        return {
            'status': 'success',
            'vulnerabilities': vulnerabilities,
            'total': len(vulnerabilities)
        }

    async def _scan_python_code(self) -> list[dict[str, Any]]:
        """Scan Python code for vulnerabilities"""
        vulnerabilities = []

        try:
            # Use Bandit for Python security scanning
            result = subprocess.run(
                ['bandit', '-r', '.', '-f', 'json', '-ll'],
                capture_output=True,
                text=True,
                timeout=120
            )

            bandit_data = json.loads(result.stdout)

            for issue in bandit_data.get('results', []):
                vulnerabilities.append({
                    'type': 'code',
                    'language': 'python',
                    'file': issue.get('filename'),
                    'line': issue.get('line_number'),
                    'vulnerability': issue.get('test_id'),
                    'severity': issue.get('issue_severity', 'MEDIUM').lower(),
                    'confidence': issue.get('issue_confidence', 'MEDIUM').lower(),
                    'description': issue.get('issue_text'),
                    'cwe': issue.get('issue_cwe', {}).get('id')
                })
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            logger.warning("Bandit not available for Python code scanning")
        except Exception as e:
            logger.error(f"Error scanning Python code: {e}")

        return vulnerabilities

    async def _scan_javascript_code(self) -> list[dict[str, Any]]:
        """Scan JavaScript code for vulnerabilities"""
        vulnerabilities = []

        # Would use ESLint security plugins or similar
        # Simplified implementation

        return vulnerabilities

    async def _scan_with_semgrep(self) -> list[dict[str, Any]]:
        """Scan code with Semgrep for security patterns"""
        vulnerabilities = []

        try:
            # Use Semgrep with security rulesets
            result = subprocess.run(
                ['semgrep', '--config=auto', '--json', '--quiet'],
                capture_output=True,
                text=True,
                timeout=180
            )

            if result.returncode == 0:
                semgrep_data = json.loads(result.stdout)

                for finding in semgrep_data.get('results', []):
                    vulnerabilities.append({
                        'type': 'code',
                        'file': finding.get('path'),
                        'line': finding.get('start', {}).get('line'),
                        'vulnerability': finding.get('check_id'),
                        'severity': self._map_semgrep_severity(finding.get('extra', {}).get('severity', 'INFO')),
                        'description': finding.get('extra', {}).get('message'),
                        'owasp': finding.get('extra', {}).get('metadata', {}).get('owasp')
                    })
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            logger.warning("Semgrep not available for code scanning")
        except Exception as e:
            logger.error(f"Error scanning with Semgrep: {e}")

        return vulnerabilities

    async def _check_cve(self, task: dict[str, Any]) -> dict[str, Any]:
        """Check specific CVE details"""
        cve_id = task.get('cve_id')

        if not cve_id:
            return {
                'status': 'error',
                'message': 'CVE ID not provided'
            }

        try:
            # Query NIST NVD API
            response = requests.get(
                f"{self.nvd_api_url}",
                params={'cveId': cve_id},
                timeout=10
            )

            if response.status_code == 200:
                cve_data = response.json()

                if cve_data.get('vulnerabilities'):
                    vuln = cve_data['vulnerabilities'][0]['cve']

                    return {
                        'status': 'success',
                        'cve': {
                            'id': vuln.get('id'),
                            'description': vuln.get('descriptions', [{}])[0].get('value'),
                            'severity': self._extract_cvss_severity(vuln.get('metrics', {})),
                            'cvss_score': self._extract_cvss_score(vuln.get('metrics', {})),
                            'published': vuln.get('published'),
                            'modified': vuln.get('lastModified')
                        }
                    }

            return {
                'status': 'error',
                'message': f'CVE {cve_id} not found'
            }

        except Exception as e:
            logger.error(f"Error checking CVE: {e}")
            return {
                'status': 'error',
                'message': str(e)
            }

    async def _generate_vulnerability_report(self, task: dict[str, Any]) -> dict[str, Any]:
        """Generate vulnerability scan report"""
        scan_result = await self._comprehensive_scan(task)

        if scan_result['status'] != 'success':
            return scan_result

        scan_data = scan_result['scan_results']

        report = {
            'title': 'Vulnerability Scan Report',
            'generated_at': datetime.utcnow().isoformat(),
            'environment': scan_data['environment'],
            'executive_summary': self._generate_executive_summary(scan_data),
            'cvss_score': scan_data['cvss_score'],
            'vulnerabilities': scan_data['vulnerabilities'],
            'statistics': scan_data['summary'],
            'recommendations': scan_data['recommendations'],
            'remediation_plan': self._generate_remediation_plan(scan_data)
        }

        return {
            'status': 'success',
            'report': report
        }

    def _generate_recommendations(self, scan_results: dict[str, Any]) -> list[str]:
        """Generate remediation recommendations"""
        recommendations = []

        if scan_results['summary']['critical_count'] > 0:
            recommendations.append("URGENT: Patch all critical vulnerabilities immediately")

        if scan_results['summary']['high_count'] > 0:
            recommendations.append("HIGH PRIORITY: Address high severity vulnerabilities within 24-48 hours")

        # Check for specific vulnerability types
        vuln_types = set()
        for severity_vulns in scan_results['vulnerabilities'].values():
            for vuln in severity_vulns:
                vuln_types.add(vuln.get('type'))

        if 'dependency' in vuln_types:
            recommendations.append("Update all vulnerable dependencies to patched versions")

        if 'container' in vuln_types:
            recommendations.append("Rebuild container images with updated base images")

        if 'code' in vuln_types:
            recommendations.append("Review and fix identified code security issues")

        recommendations.append("Implement automated vulnerability scanning in CI/CD pipeline")
        recommendations.append("Establish regular vulnerability assessment schedule")

        return recommendations

    def _calculate_cvss_score(self, scan_results: dict[str, Any]) -> float:
        """Calculate overall CVSS score"""
        if scan_results['summary']['critical_count'] > 0:
            return 9.5  # Critical
        elif scan_results['summary']['high_count'] > 0:
            return 7.5  # High
        elif scan_results['summary']['medium_count'] > 0:
            return 5.0  # Medium
        elif scan_results['summary']['low_count'] > 0:
            return 2.0  # Low
        else:
            return 0.0  # None

    def _generate_executive_summary(self, scan_data: dict[str, Any]) -> str:
        """Generate executive summary"""
        total = scan_data['summary']['total_vulnerabilities']
        critical = scan_data['summary']['critical_count']
        high = scan_data['summary']['high_count']

        if critical > 0:
            return f"CRITICAL: Found {total} vulnerabilities including {critical} critical issues requiring immediate attention."
        elif high > 0:
            return f"HIGH RISK: Identified {total} vulnerabilities with {high} high severity issues."
        elif total > 0:
            return f"MODERATE RISK: Detected {total} vulnerabilities, mostly medium and low severity."
        else:
            return "SECURE: No vulnerabilities detected in the current scan."

    def _generate_remediation_plan(self, scan_data: dict[str, Any]) -> list[dict[str, str]]:
        """Generate remediation plan"""
        plan = []

        # Group vulnerabilities by type and severity
        for severity in ['critical', 'high', 'medium', 'low']:
            vulns = scan_data['vulnerabilities'].get(severity, [])
            if vulns:
                timeline = {
                    'critical': 'Immediately',
                    'high': 'Within 48 hours',
                    'medium': 'Within 1 week',
                    'low': 'Within 1 month'
                }[severity]

                plan.append({
                    'severity': severity.upper(),
                    'count': len(vulns),
                    'timeline': timeline,
                    'action': f"Remediate {len(vulns)} {severity} severity vulnerabilities"
                })

        return plan

    def _map_severity(self, severity: str) -> str:
        """Map severity to standard levels"""
        severity_map = {
            'CRITICAL': 'critical',
            'HIGH': 'high',
            'MEDIUM': 'medium',
            'MODERATE': 'medium',
            'LOW': 'low',
            'INFO': 'low',
            'UNKNOWN': 'medium'
        }
        return severity_map.get(severity.upper(), 'medium')

    def _map_semgrep_severity(self, severity: str) -> str:
        """Map Semgrep severity to standard levels"""
        severity_map = {
            'ERROR': 'high',
            'WARNING': 'medium',
            'INFO': 'low'
        }
        return severity_map.get(severity.upper(), 'medium')

    def _extract_cvss_severity(self, metrics: dict) -> str:
        """Extract CVSS severity from metrics"""
        # Check for CVSS v3
        if 'cvssMetricV31' in metrics:
            score = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
        elif 'cvssMetricV30' in metrics:
            score = metrics['cvssMetricV30'][0]['cvssData']['baseScore']
        elif 'cvssMetricV2' in metrics:
            score = metrics['cvssMetricV2'][0]['cvssData']['baseScore']
        else:
            return 'UNKNOWN'

        if score >= 9.0:
            return 'critical'
        elif score >= 7.0:
            return 'high'
        elif score >= 4.0:
            return 'medium'
        else:
            return 'low'

    def _extract_cvss_score(self, metrics: dict) -> float:
        """Extract CVSS score from metrics"""
        if 'cvssMetricV31' in metrics:
            return metrics['cvssMetricV31'][0]['cvssData']['baseScore']
        elif 'cvssMetricV30' in metrics:
            return metrics['cvssMetricV30'][0]['cvssData']['baseScore']
        elif 'cvssMetricV2' in metrics:
            return metrics['cvssMetricV2'][0]['cvssData']['baseScore']
        else:
            return 0.0

    def _determine_scan_priority(self, situation: dict[str, Any]) -> str:
        """Determine scan priority"""
        if situation['environment'] == 'production':
            return 'critical'
        elif situation['scan_type'] == 'comprehensive':
            return 'high'
        else:
            return 'medium'