"""
Sub-Agent 1: Vulnerability Scanner
==================================

Real-time vulnerability monitoring during fixes:
- Continuous dependency scanning
- CVE monitoring
- Secret exposure detection
- Code vulnerability analysis
- Attack pattern recognition

Maintains 95% security score through proactive monitoring.
"""

import asyncio
import json
import logging
import subprocess
import time
from dataclasses import asdict, dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional

import aiofiles

logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityReport:
    """Structured vulnerability report"""
    id: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    category: str  # DEPENDENCY, SECRET, CODE, INFRASTRUCTURE
    description: str
    file_path: Optional[str]
    line_number: Optional[int]
    cve_id: Optional[str]
    fix_available: bool
    fix_command: Optional[str]
    detected_at: datetime
    impact_score: int  # 1-100

@dataclass
class SecurityMetrics:
    """Security metrics tracking"""
    total_scans: int
    vulnerabilities_found: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    secrets_exposed: int
    dependencies_vulnerable: int
    security_score: float
    last_scan: datetime

class VulnerabilityScanner:
    """
    Real-time vulnerability scanner for continuous security monitoring
    
    Features:
    - NPM/Pip dependency vulnerability scanning
    - Secret exposure detection (regex patterns)
    - Code vulnerability analysis
    - CVE database integration
    - Real-time monitoring during fixes
    """
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.scan_interval = 300  # 5 minutes
        self.monitoring = False
        self.vulnerabilities: list[VulnerabilityReport] = []
        self.metrics = SecurityMetrics(
            total_scans=0,
            vulnerabilities_found=0,
            critical_count=0,
            high_count=0,
            medium_count=0,
            low_count=0,
            secrets_exposed=0,
            dependencies_vulnerable=0,
            security_score=95.0,
            last_scan=datetime.now()
        )
        
        # Secret detection patterns (OWASP compliant)
        self.secret_patterns = {
            'api_key': r'(?i)(api[_-]?key|apikey)\s*[:=]\s*["\']?([a-zA-Z0-9_\-]{20,})["\']?',
            'jwt_secret': r'(?i)(jwt[_-]?secret|jwt[_-]?key)\s*[:=]\s*["\']?([a-zA-Z0-9_\-\.\!\@\#\$\%\^\&\*]{32,})["\']?',
            'database_url': r'(?i)(database[_-]?url|db[_-]?url)\s*[:=]\s*["\']?(postgresql://[^"\'\s]+)["\']?',
            'private_key': r'-----BEGIN\s+(RSA\s+|EC\s+)?PRIVATE\s+KEY-----',
            'aws_key': r'(?i)(aws[_-]?access[_-]?key|aws[_-]?secret)\s*[:=]\s*["\']?([A-Z0-9]{20,})["\']?',
            'openai_key': r'sk-[a-zA-Z0-9]{48,}',
            'pusher_secret': r'(?i)(pusher[_-]?secret)\s*[:=]\s*["\']?([a-f0-9]{40})["\']?'
        }
        
        # Vulnerability severity weights for scoring
        self.severity_weights = {
            'CRITICAL': -50,
            'HIGH': -25,
            'MEDIUM': -10,
            'LOW': -2
        }
    
    async def start_monitoring(self) -> None:
        """Start continuous vulnerability monitoring"""
        self.monitoring = True
        logger.info("ðŸ”’ Vulnerability Scanner: Starting continuous monitoring")
        
        while self.monitoring:
            try:
                await self.run_comprehensive_scan()
                await self.update_security_score()
                await self.generate_alerts()
                await asyncio.sleep(self.scan_interval)
            except Exception as e:
                logger.error(f"Vulnerability scanning error: {e}")
                await asyncio.sleep(60)  # Retry after 1 minute on error
    
    def stop_monitoring(self) -> None:
        """Stop continuous monitoring"""
        self.monitoring = False
        logger.info("ðŸ”’ Vulnerability Scanner: Monitoring stopped")
    
    async def run_comprehensive_scan(self) -> dict:
        """Run comprehensive vulnerability scan"""
        logger.info("ðŸ” Running comprehensive vulnerability scan...")
        
        scan_results = {
            'dependency_scan': await self.scan_dependencies(),
            'secret_scan': await self.scan_secrets(),
            'code_scan': await self.scan_code_vulnerabilities(),
            'infrastructure_scan': await self.scan_infrastructure()
        }
        
        self.metrics.total_scans += 1
        self.metrics.last_scan = datetime.now()
        
        # Consolidate vulnerabilities
        all_vulnerabilities = []
        for scan_type, results in scan_results.items():
            all_vulnerabilities.extend(results.get('vulnerabilities', []))
        
        self.vulnerabilities = all_vulnerabilities
        self.update_metrics()
        
        logger.info(f"ðŸ” Scan complete: {len(all_vulnerabilities)} vulnerabilities found")
        return scan_results
    
    async def scan_dependencies(self) -> dict:
        """Scan dependencies for known vulnerabilities"""
        vulnerabilities = []
        
        try:
            # NPM audit for frontend
            npm_result = await self.run_npm_audit()
            vulnerabilities.extend(npm_result)
            
            # Pip audit for backend
            pip_result = await self.run_pip_audit()
            vulnerabilities.extend(pip_result)
            
        except Exception as e:
            logger.error(f"Dependency scan error: {e}")
        
        return {
            'scan_type': 'dependency',
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat()
        }
    
    async def run_npm_audit(self) -> list[VulnerabilityReport]:
        """Run NPM audit for frontend dependencies"""
        vulnerabilities = []
        
        try:
            result = subprocess.run(
                ['npm', 'audit', '--audit-level=moderate', '--json'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.stdout:
                audit_data = json.loads(result.stdout)
                vulnerabilities = self.parse_npm_audit(audit_data)
                
        except subprocess.TimeoutExpired:
            logger.warning("NPM audit timed out")
        except json.JSONDecodeError:
            logger.warning("Failed to parse NPM audit JSON")
        except Exception as e:
            logger.error(f"NPM audit error: {e}")
        
        return vulnerabilities
    
    async def run_pip_audit(self) -> list[VulnerabilityReport]:
        """Run pip-audit for Python dependencies"""
        vulnerabilities = []
        
        try:
            result = subprocess.run(
                ['pip-audit', '--format=json'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.stdout:
                audit_data = json.loads(result.stdout)
                vulnerabilities = self.parse_pip_audit(audit_data)
                
        except subprocess.TimeoutExpired:
            logger.warning("Pip audit timed out")
        except json.JSONDecodeError:
            logger.warning("Failed to parse pip audit JSON")
        except Exception as e:
            logger.error(f"Pip audit error: {e}")
        
        return vulnerabilities
    
    def parse_npm_audit(self, audit_data: dict) -> list[VulnerabilityReport]:
        """Parse NPM audit results"""
        vulnerabilities = []
        
        if 'vulnerabilities' in audit_data:
            for pkg_name, vuln_data in audit_data['vulnerabilities'].items():
                severity = vuln_data.get('severity', 'UNKNOWN').upper()
                
                vuln = VulnerabilityReport(
                    id=f"npm-{pkg_name}-{int(time.time())}",
                    severity=severity,
                    category='DEPENDENCY',
                    description=f"Vulnerable package: {pkg_name} - {vuln_data.get('title', 'Unknown vulnerability')}",
                    file_path="package.json",
                    line_number=None,
                    cve_id=vuln_data.get('cve', None),
                    fix_available=bool(vuln_data.get('fixAvailable')),
                    fix_command=f"npm audit fix --force" if vuln_data.get('fixAvailable') else None,
                    detected_at=datetime.now(),
                    impact_score=self.calculate_impact_score(severity, 'DEPENDENCY')
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def parse_pip_audit(self, audit_data: dict) -> list[VulnerabilityReport]:
        """Parse pip-audit results"""
        vulnerabilities = []
        
        if isinstance(audit_data, list):
            for vuln_item in audit_data:
                pkg_name = vuln_item.get('package', 'unknown')
                vuln_id = vuln_item.get('id', 'unknown')
                
                vuln = VulnerabilityReport(
                    id=f"pip-{pkg_name}-{vuln_id}",
                    severity='HIGH',  # Default for pip vulnerabilities
                    category='DEPENDENCY',
                    description=f"Vulnerable package: {pkg_name} - {vuln_item.get('description', 'Unknown vulnerability')}",
                    file_path="requirements.txt",
                    line_number=None,
                    cve_id=vuln_id,
                    fix_available=bool(vuln_item.get('fix_versions')),
                    fix_command=f"pip install {pkg_name}>={vuln_item.get('fix_versions', ['latest'])[0]}" if vuln_item.get('fix_versions') else None,
                    detected_at=datetime.now(),
                    impact_score=self.calculate_impact_score('HIGH', 'DEPENDENCY')
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def scan_secrets(self) -> dict:
        """Scan for exposed secrets in codebase"""
        vulnerabilities = []
        
        # Files to scan
        scan_files = [
            '**/*.py', '**/*.js', '**/*.ts', '**/*.jsx', '**/*.tsx',
            '**/*.env*', '**/*.json', '**/*.yaml', '**/*.yml',
            '**/*.md', '**/*.txt', '**/*.sh'
        ]
        
        for pattern in scan_files:
            for file_path in self.project_root.glob(pattern):
                if file_path.is_file() and not self.should_skip_file(file_path):
                    file_vulnerabilities = await self.scan_file_for_secrets(file_path)
                    vulnerabilities.extend(file_vulnerabilities)
        
        return {
            'scan_type': 'secret',
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat()
        }
    
    async def scan_file_for_secrets(self, file_path: Path) -> list[VulnerabilityReport]:
        """Scan individual file for secrets"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(file_path, encoding='utf-8', errors='ignore') as f:
                content = await f.read()
            
            for secret_type, pattern in self.secret_patterns.items():
                import re
                matches = re.finditer(pattern, content, re.MULTILINE)
                
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1
                    
                    # Skip if it's a placeholder or template
                    matched_text = match.group(0)
                    if self.is_placeholder_secret(matched_text):
                        continue
                    
                    vuln = VulnerabilityReport(
                        id=f"secret-{secret_type}-{file_path.name}-{line_number}",
                        severity='CRITICAL',
                        category='SECRET',
                        description=f"Exposed {secret_type} found in {file_path.name}",
                        file_path=str(file_path),
                        line_number=line_number,
                        cve_id=None,
                        fix_available=True,
                        fix_command=f"Replace with environment variable in {file_path}",
                        detected_at=datetime.now(),
                        impact_score=self.calculate_impact_score('CRITICAL', 'SECRET')
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")
        
        return vulnerabilities
    
    def is_placeholder_secret(self, text: str) -> bool:
        """Check if secret is a placeholder/template value"""
        placeholder_indicators = [
            'your_', 'YOUR_', 'CHANGE_ME', 'TODO:', 'PLACEHOLDER',
            'example', 'EXAMPLE', 'test', 'TEST', 'xxx', 'XXX',
            'replace', 'REPLACE', 'here', 'HERE'
        ]
        
        return any(indicator in text for indicator in placeholder_indicators)
    
    async def scan_code_vulnerabilities(self) -> dict:
        """Scan for code-level vulnerabilities"""
        vulnerabilities = []
        
        # Check for common vulnerability patterns
        vulnerability_patterns = {
            'sql_injection': r'(?i)(execute|exec|query)\s*\(\s*["\'][^"\']*\+',
            'xss_vulnerability': r'(?i)(innerHTML|outerHTML)\s*=\s*[^;]*\+',
            'command_injection': r'(?i)(subprocess|os\.system|exec)\s*\([^)]*\+',
            'path_traversal': r'(?i)(open|read|write)\s*\([^)]*\.\.[/\\]',
            'hardcoded_crypto': r'(?i)(md5|sha1)\s*\(',
            'insecure_random': r'(?i)(random\.random|math\.random)\s*\('
        }
        
        for pattern_name, pattern in vulnerability_patterns.items():
            code_vulnerabilities = await self.scan_code_pattern(pattern, pattern_name)
            vulnerabilities.extend(code_vulnerabilities)
        
        return {
            'scan_type': 'code',
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat()
        }
    
    async def scan_code_pattern(self, pattern: str, vuln_type: str) -> list[VulnerabilityReport]:
        """Scan code for specific vulnerability pattern"""
        vulnerabilities = []
        
        code_files = ['**/*.py', '**/*.js', '**/*.ts', '**/*.jsx', '**/*.tsx']
        
        for file_pattern in code_files:
            for file_path in self.project_root.glob(file_pattern):
                if file_path.is_file() and not self.should_skip_file(file_path):
                    try:
                        async with aiofiles.open(file_path, encoding='utf-8', errors='ignore') as f:
                            content = await f.read()
                        
                        import re
                        matches = re.finditer(pattern, content, re.MULTILINE)
                        
                        for match in matches:
                            line_number = content[:match.start()].count('\n') + 1
                            
                            vuln = VulnerabilityReport(
                                id=f"code-{vuln_type}-{file_path.name}-{line_number}",
                                severity='HIGH',
                                category='CODE',
                                description=f"Potential {vuln_type} vulnerability in {file_path.name}",
                                file_path=str(file_path),
                                line_number=line_number,
                                cve_id=None,
                                fix_available=True,
                                fix_command=f"Review and fix {vuln_type} in {file_path}",
                                detected_at=datetime.now(),
                                impact_score=self.calculate_impact_score('HIGH', 'CODE')
                            )
                            vulnerabilities.append(vuln)
                    
                    except Exception as e:
                        logger.error(f"Error scanning {file_path}: {e}")
        
        return vulnerabilities
    
    async def scan_infrastructure(self) -> dict:
        """Scan infrastructure configuration for vulnerabilities"""
        vulnerabilities = []
        
        # Check Docker configurations
        docker_files = list(self.project_root.glob('**/Dockerfile*')) + list(self.project_root.glob('**/docker-compose*.yml'))
        
        for docker_file in docker_files:
            docker_vulnerabilities = await self.scan_docker_file(docker_file)
            vulnerabilities.extend(docker_vulnerabilities)
        
        return {
            'scan_type': 'infrastructure',
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat()
        }
    
    async def scan_docker_file(self, file_path: Path) -> list[VulnerabilityReport]:
        """Scan Docker file for security issues"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(file_path, encoding='utf-8') as f:
                content = await f.read()
            
            # Check for common Docker security issues
            security_checks = {
                'root_user': r'(?i)USER\s+root',
                'latest_tag': r'(?i)FROM\s+[^:]+:latest',
                'privileged_mode': r'(?i)--privileged',
                'insecure_registry': r'(?i)--insecure-registry'
            }
            
            for check_name, pattern in security_checks.items():
                import re
                if re.search(pattern, content):
                    vuln = VulnerabilityReport(
                        id=f"docker-{check_name}-{file_path.name}",
                        severity='MEDIUM',
                        category='INFRASTRUCTURE',
                        description=f"Docker security issue: {check_name} in {file_path.name}",
                        file_path=str(file_path),
                        line_number=None,
                        cve_id=None,
                        fix_available=True,
                        fix_command=f"Fix {check_name} in {file_path}",
                        detected_at=datetime.now(),
                        impact_score=self.calculate_impact_score('MEDIUM', 'INFRASTRUCTURE')
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning Docker file {file_path}: {e}")
        
        return vulnerabilities
    
    def should_skip_file(self, file_path: Path) -> bool:
        """Check if file should be skipped during scanning"""
        skip_patterns = [
            'node_modules', '.git', '__pycache__', '.pytest_cache',
            'venv', '.venv', 'build', 'dist', '.next', 'coverage',
            '.nyc_output', 'logs', '.log'
        ]
        
        return any(pattern in str(file_path) for pattern in skip_patterns)
    
    def calculate_impact_score(self, severity: str, category: str) -> int:
        """Calculate vulnerability impact score (1-100)"""
        base_scores = {
            'CRITICAL': 90,
            'HIGH': 70,
            'MEDIUM': 40,
            'LOW': 20
        }
        
        category_multipliers = {
            'SECRET': 1.2,
            'DEPENDENCY': 1.0,
            'CODE': 1.1,
            'INFRASTRUCTURE': 0.9
        }
        
        base_score = base_scores.get(severity, 20)
        multiplier = category_multipliers.get(category, 1.0)
        
        return min(int(base_score * multiplier), 100)
    
    def update_metrics(self) -> None:
        """Update security metrics based on current vulnerabilities"""
        self.metrics.vulnerabilities_found = len(self.vulnerabilities)
        self.metrics.critical_count = len([v for v in self.vulnerabilities if v.severity == 'CRITICAL'])
        self.metrics.high_count = len([v for v in self.vulnerabilities if v.severity == 'HIGH'])
        self.metrics.medium_count = len([v for v in self.vulnerabilities if v.severity == 'MEDIUM'])
        self.metrics.low_count = len([v for v in self.vulnerabilities if v.severity == 'LOW'])
        self.metrics.secrets_exposed = len([v for v in self.vulnerabilities if v.category == 'SECRET'])
        self.metrics.dependencies_vulnerable = len([v for v in self.vulnerabilities if v.category == 'DEPENDENCY'])
    
    async def update_security_score(self) -> None:
        """Update security score based on vulnerabilities"""
        base_score = 100.0
        
        for vuln in self.vulnerabilities:
            weight = self.severity_weights.get(vuln.severity, -1)
            base_score += weight
        
        # Ensure score doesn't go below 0
        self.metrics.security_score = max(0.0, base_score)
        
        logger.info(f"ðŸ”’ Security Score: {self.metrics.security_score:.1f}%")
    
    async def generate_alerts(self) -> None:
        """Generate alerts for critical security issues"""
        critical_vulnerabilities = [v for v in self.vulnerabilities if v.severity == 'CRITICAL']
        
        if critical_vulnerabilities:
            logger.critical(f"ðŸš¨ CRITICAL SECURITY ALERT: {len(critical_vulnerabilities)} critical vulnerabilities detected!")
            
            for vuln in critical_vulnerabilities:
                logger.critical(f"  - {vuln.description} in {vuln.file_path}")
        
        # Alert if security score drops below threshold
        if self.metrics.security_score < 95.0:
            logger.warning(f"âš ï¸  Security score below threshold: {self.metrics.security_score:.1f}% (target: 95%)")
    
    async def get_security_report(self) -> dict:
        """Generate comprehensive security report"""
        return {
            'timestamp': datetime.now().isoformat(),
            'security_score': self.metrics.security_score,
            'metrics': asdict(self.metrics),
            'vulnerabilities': [asdict(v) for v in self.vulnerabilities],
            'recommendations': self.generate_recommendations(),
            'compliance_status': {
                'owasp_2025': self.check_owasp_compliance(),
                'maintains_95_percent': self.metrics.security_score >= 95.0
            }
        }
    
    def generate_recommendations(self) -> list[dict]:
        """Generate security recommendations"""
        recommendations = []
        
        if self.metrics.critical_count > 0:
            recommendations.append({
                'priority': 'CRITICAL',
                'title': 'Fix Critical Vulnerabilities',
                'description': f'{self.metrics.critical_count} critical vulnerabilities require immediate attention'
            })
        
        if self.metrics.secrets_exposed > 0:
            recommendations.append({
                'priority': 'HIGH',
                'title': 'Remove Exposed Secrets',
                'description': f'{self.metrics.secrets_exposed} exposed secrets detected in codebase'
            })
        
        if self.metrics.dependencies_vulnerable > 0:
            recommendations.append({
                'priority': 'MEDIUM',
                'title': 'Update Vulnerable Dependencies',
                'description': f'{self.metrics.dependencies_vulnerable} vulnerable dependencies need updates'
            })
        
        return recommendations
    
    def check_owasp_compliance(self) -> bool:
        """Check OWASP 2025 compliance"""
        # OWASP Top 10 2025 compliance checks
        critical_issues = self.metrics.critical_count
        high_issues = self.metrics.high_count
        secrets_exposed = self.metrics.secrets_exposed
        
        # Basic compliance: no critical issues, minimal high issues, no exposed secrets
        return critical_issues == 0 and high_issues <= 2 and secrets_exposed == 0
