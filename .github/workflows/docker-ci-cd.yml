# ============================================
# TOOLBOXAI DOCKER CI/CD PIPELINE
# ============================================
# Comprehensive Docker-based CI/CD pipeline for ToolBoxAI-Solutions
# Features: Build, Test, Security Scan, Deploy with Rollback
# Updated: 2025-09-25
# ============================================

name: ğŸ³ Docker CI/CD Pipeline

on:
  push:
    branches: [ main, staging, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, staging ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  DOCKER_BUILDX_VERSION: v0.12.1
  TRIVY_VERSION: 0.48.3

jobs:
  # ============================================
  # PREPARATION & SETUP
  # ============================================
  setup:
    name: ğŸ”§ Setup & Preparation
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-keys.outputs.cache-key }}
      build-matrix: ${{ steps.build-matrix.outputs.matrix }}
      environment: ${{ steps.environment.outputs.env }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ·ï¸ Determine Version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${GITHUB_SHA:0:8}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: ğŸ¯ Determine Environment
        id: environment
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ $GITHUB_REF == refs/tags/* ]]; then
            ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENV="staging"
          else
            ENV="development"
          fi
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "Environment: $ENV"

      - name: ğŸ”‘ Generate Cache Keys
        id: cache-keys
        run: |
          CACHE_KEY="toolboxai-docker-${{ runner.os }}-${{ hashFiles('**/Dockerfile*', '**/docker-compose*.yml', '**/package*.json', '**/requirements*.txt', '**/pyproject.toml') }}"
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Setup Build Matrix
        id: build-matrix
        run: |
          # Define services to build
          cat << EOF > matrix.json
          {
            "include": [
              {
                "service": "fastapi-main",
                "dockerfile": "infrastructure/docker/Dockerfile.backend",
                "context": ".",
                "platforms": "linux/amd64,linux/arm64",
                "cache-to": "type=gha,mode=max,scope=fastapi",
                "cache-from": "type=gha,scope=fastapi"
              },
              {
                "service": "dashboard-frontend",
                "dockerfile": "infrastructure/docker/dashboard.Dockerfile",
                "context": ".",
                "platforms": "linux/amd64,linux/arm64",
                "cache-to": "type=gha,mode=max,scope=dashboard",
                "cache-from": "type=gha,scope=dashboard"
              },
              {
                "service": "mcp-server",
                "dockerfile": "infrastructure/docker/mcp-server.Dockerfile",
                "context": ".",
                "platforms": "linux/amd64",
                "cache-to": "type=gha,mode=max,scope=mcp",
                "cache-from": "type=gha,scope=mcp"
              },
              {
                "service": "agent-coordinator",
                "dockerfile": "infrastructure/docker/agent-coordinator.Dockerfile",
                "context": ".",
                "platforms": "linux/amd64",
                "cache-to": "type=gha,mode=max,scope=agent",
                "cache-from": "type=gha,scope=agent"
              },
              {
                "service": "flask-bridge",
                "dockerfile": "infrastructure/docker/flask-bridge.Dockerfile",
                "context": ".",
                "platforms": "linux/amd64",
                "cache-to": "type=gha,mode=max,scope=flask",
                "cache-from": "type=gha,scope=flask"
              }
            ]
          }
          EOF
          echo "matrix=$(cat matrix.json)" >> $GITHUB_OUTPUT

  # ============================================
  # CODE QUALITY & LINTING
  # ============================================
  quality:
    name: ğŸ” Code Quality
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: ğŸ”§ Install Dependencies
        run: |
          pip install -r requirements.txt
          npm install

      - name: ğŸ“Š Python Linting
        run: |
          pip install black ruff mypy
          black --check . || exit 1
          ruff check . || exit 1
          mypy apps/backend --ignore-missing-imports || true

      - name: ğŸ“Š JavaScript/TypeScript Linting
        run: |
          npm run dashboard:lint

      - name: ğŸ“„ Dockerfile Linting
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: infrastructure/docker/Dockerfile.backend
          failure-threshold: error

  # ============================================
  # DOCKER BUILD & CACHE
  # ============================================
  build:
    name: ğŸ”¨ Build Docker Images
    runs-on: ubuntu-latest
    needs: [setup, quality]
    if: github.event.inputs.skip_tests != 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.build-matrix) }}
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: ${{ env.DOCKER_BUILDX_VERSION }}
          driver-opts: |
            network=host
            image=moby/buildkit:v0.12.5

      - name: ğŸ” Login to Docker Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: ğŸ·ï¸ Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/toolboxai/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.setup.outputs.version }}
          labels: |
            org.opencontainers.image.title=ToolBoxAI ${{ matrix.service }}
            org.opencontainers.image.description=ToolBoxAI Solutions - ${{ matrix.service }}
            org.opencontainers.image.vendor=ToolBoxAI Solutions
            maintainer=ToolBoxAI DevOps Team

      - name: ğŸ”¨ Build and Export
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: ${{ matrix.platforms }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: ${{ matrix.cache-from }}
          cache-to: ${{ matrix.cache-to }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            VERSION=${{ needs.setup.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
          target: production
          provenance: false
          sbom: false

      - name: ğŸ“ Output Image Details
        run: |
          echo "::notice::Built image: ${{ steps.meta.outputs.tags }}"
          echo "::notice::Size: $(docker images --format 'table {{.Repository}}\t{{.Tag}}\t{{.Size}}' | grep '${{ matrix.service }}')"

  # ============================================
  # SECURITY SCANNING
  # ============================================
  security:
    name: ğŸ” Security Scanning
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: success() || failure()
    strategy:
      matrix:
        service: [fastapi-main, dashboard-frontend, mcp-server, agent-coordinator, flask-bridge]
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ›¡ï¸ Run Trivy Security Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/toolboxai/${{ matrix.service }}:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-${{ matrix.service }}.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '0'

      - name: ğŸ“¤ Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-${{ matrix.service }}.sarif'
          category: 'trivy-${{ matrix.service }}'

      - name: ğŸ” Vulnerability Summary
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${{ github.workspace }}:/workspace \
            aquasec/trivy:${{ env.TRIVY_VERSION }} image \
            --format json \
            --output /workspace/trivy-${{ matrix.service }}.json \
            ${{ env.REGISTRY }}/toolboxai/${{ matrix.service }}:${{ github.sha }}

          # Create summary
          if [ -f trivy-${{ matrix.service }}.json ]; then
            HIGH=$(jq '.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH") | .VulnerabilityID' trivy-${{ matrix.service }}.json | wc -l)
            CRITICAL=$(jq '.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL") | .VulnerabilityID' trivy-${{ matrix.service }}.json | wc -l)
            echo "::notice::${{ matrix.service }} - HIGH: $HIGH, CRITICAL: $CRITICAL vulnerabilities"

            if [ $CRITICAL -gt 5 ]; then
              echo "::error::Too many critical vulnerabilities in ${{ matrix.service }}: $CRITICAL"
              exit 1
            fi
          fi

  # ============================================
  # INTEGRATION TESTING
  # ============================================
  test:
    name: ğŸ§ª Integration Tests
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event.inputs.skip_tests != 'true'
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: ğŸ—ï¸ Create Test Environment
        run: |
          # Create test environment file
          cat << EOF > .env.test
          DATABASE_URL=postgresql://test_user:test_pass@localhost:5432/test_db
          REDIS_URL=redis://localhost:6379/0
          JWT_SECRET_KEY=test_secret_key_for_ci
          ENVIRONMENT=test
          DEBUG=false
          LOG_LEVEL=WARNING
          PUSHER_ENABLED=false
          OPENAI_API_KEY=test_key
          EOF

      - name: ğŸ”„ Start Test Stack
        run: |
          # Use built images for testing
          export IMAGE_TAG=${{ github.sha }}
          docker compose -f infrastructure/docker/docker-compose.dev.yml up -d --wait
        env:
          DATABASE_URL: postgresql://test_user:test_pass@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0

      - name: â³ Wait for Services
        run: |
          timeout 300 bash -c '
            while ! curl -f http://localhost:8009/health; do
              echo "Waiting for FastAPI service..."
              sleep 5
            done
          '
          timeout 300 bash -c '
            while ! curl -f http://localhost:5179; do
              echo "Waiting for Dashboard service..."
              sleep 5
            done
          '

      - name: ğŸ§ª Run Backend Tests
        run: |
          docker exec toolboxai-fastapi pytest tests/ -v \
            --maxfail=5 \
            --tb=short \
            --durations=10 \
            --cov=apps/backend \
            --cov-report=xml \
            --cov-report=term-missing

      - name: ğŸ§ª Run Frontend Tests
        run: |
          docker exec toolboxai-dashboard-frontend npm test -- --passWithNoTests --watchAll=false

      - name: ğŸ”— Run Integration Tests
        run: |
          # Test inter-service communication
          curl -f http://localhost:8009/api/v1/health || exit 1
          curl -f http://localhost:5179/ || exit 1

          # Test database connectivity
          docker exec toolboxai-fastapi python -c "
          from database.connection import get_session
          from sqlalchemy import text
          with get_session() as session:
              result = session.execute(text('SELECT 1'))
              assert result.scalar() == 1
              print('Database connectivity: OK')
          "

      - name: ğŸ“Š Upload Coverage
        if: always()
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: integration
          name: integration-tests

      - name: ğŸ“ Collect Logs
        if: failure()
        run: |
          mkdir -p logs
          docker compose -f infrastructure/docker/docker-compose.dev.yml logs --no-color > logs/docker-compose.log
          docker ps -a > logs/containers.log

      - name: ğŸ“¤ Upload Test Artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-failure-logs
          path: logs/
          retention-days: 7

  # ============================================
  # PERFORMANCE TESTING
  # ============================================
  performance:
    name: âš¡ Performance Tests
    runs-on: ubuntu-latest
    needs: [setup, test]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸš€ Setup Performance Testing
        run: |
          # Install k6 for load testing
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: ğŸ”„ Start Services for Performance Testing
        run: |
          export IMAGE_TAG=${{ github.sha }}
          docker compose -f infrastructure/docker/docker-compose.dev.yml up -d --wait

      - name: âš¡ Run Load Tests
        run: |
          # Create k6 performance test script
          cat << 'EOF' > performance-test.js
          import http from 'k6/http';
          import { check, sleep } from 'k6';

          export const options = {
            stages: [
              { duration: '2m', target: 20 },
              { duration: '5m', target: 20 },
              { duration: '2m', target: 50 },
              { duration: '5m', target: 50 },
              { duration: '2m', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<500'],
              http_req_failed: ['rate<0.02'],
            },
          };

          export default function() {
            const responses = http.batch([
              ['GET', 'http://localhost:8009/health'],
              ['GET', 'http://localhost:5179/'],
              ['GET', 'http://localhost:8009/api/v1/health'],
            ]);

            responses.forEach((res) => {
              check(res, {
                'status is 200': (r) => r.status === 200,
                'response time < 500ms': (r) => r.timings.duration < 500,
              });
            });

            sleep(1);
          }
          EOF

          k6 run performance-test.js

  # ============================================
  # DEPLOYMENT - STAGING
  # ============================================
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [setup, test, security]
    if: |
      (github.ref == 'refs/heads/staging' ||
       (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging')) &&
      success()
    environment:
      name: staging
      url: https://staging.toolboxai.solutions
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸš€ Deploy to Staging Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: ${{ secrets.STAGING_PORT }}
          script: |
            set -e
            cd /opt/toolboxai-staging

            # Backup current version
            docker compose -f infrastructure/docker/docker-compose.staging.yml down
            docker tag toolboxai/fastapi-main:latest toolboxai/fastapi-main:backup || true

            # Pull new images
            export IMAGE_TAG=${{ github.sha }}
            docker compose -f infrastructure/docker/docker-compose.staging.yml pull

            # Deploy new version
            docker compose -f infrastructure/docker/docker-compose.staging.yml up -d --wait

            # Health check
            timeout 300 bash -c '
              while ! curl -f https://staging.toolboxai.solutions/health; do
                echo "Waiting for staging deployment..."
                sleep 10
              done
            '

            echo "Staging deployment successful!"

      - name: ğŸ”” Notify Deployment Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author
          text: 'ğŸš€ Staging deployment successful!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: ğŸ”” Notify Deployment Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          fields: repo,message,commit,author
          text: 'âŒ Staging deployment failed!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # ============================================
  # DEPLOYMENT - PRODUCTION
  # ============================================
  deploy-production:
    name: ğŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    needs: [setup, test, security, performance]
    if: |
      (github.ref == 'refs/heads/main' ||
       startsWith(github.ref, 'refs/tags/') ||
       (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')) &&
      success()
    environment:
      name: production
      url: https://toolboxai.solutions
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ›¡ï¸ Final Security Check
        run: |
          # Additional production security validations
          echo "Running final security checks..."

          # Check for sensitive data in images
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:${{ env.TRIVY_VERSION }} image \
            --severity CRITICAL \
            --exit-code 1 \
            ${{ env.REGISTRY }}/toolboxai/fastapi-main:${{ github.sha }}

      - name: ğŸš€ Deploy to Production (Blue-Green)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT }}
          script: |
            set -e
            cd /opt/toolboxai-production

            # Determine current environment (blue/green)
            CURRENT_ENV=$(cat current_env.txt 2>/dev/null || echo "blue")
            if [ "$CURRENT_ENV" = "blue" ]; then
              NEW_ENV="green"
            else
              NEW_ENV="blue"
            fi

            echo "Deploying to $NEW_ENV environment..."

            # Deploy to new environment
            export DEPLOY_ENV=$NEW_ENV
            export IMAGE_TAG=${{ github.sha }}

            # Pull new images
            docker compose -f infrastructure/docker/docker-compose.prod-${NEW_ENV}.yml pull

            # Start new environment
            docker compose -f infrastructure/docker/docker-compose.prod-${NEW_ENV}.yml up -d --wait

            # Health check new environment
            timeout 300 bash -c "
              while ! curl -f http://localhost:808${NEW_ENV: -1}/health; do
                echo 'Waiting for $NEW_ENV environment...'
                sleep 10
              done
            "

            # Switch traffic (update load balancer)
            ./scripts/switch-traffic.sh $NEW_ENV

            # Wait and verify
            sleep 30
            curl -f https://toolboxai.solutions/health

            # Mark new environment as current
            echo "$NEW_ENV" > current_env.txt

            # Stop old environment
            OLD_ENV=$CURRENT_ENV
            docker compose -f infrastructure/docker/docker-compose.prod-${OLD_ENV}.yml down

            echo "Production deployment successful! Active environment: $NEW_ENV"

      - name: ğŸ”„ Rollback on Failure
        if: failure()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT }}
          script: |
            set -e
            cd /opt/toolboxai-production

            echo "Deployment failed, initiating rollback..."

            # Get previous environment
            CURRENT_ENV=$(cat current_env.txt 2>/dev/null || echo "blue")

            # Switch back to previous environment
            ./scripts/switch-traffic.sh $CURRENT_ENV

            # Ensure old environment is running
            docker compose -f infrastructure/docker/docker-compose.prod-${CURRENT_ENV}.yml up -d --wait

            echo "Rollback completed successfully"

      - name: ğŸ”” Notify Production Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author
          text: 'ğŸŒŸ Production deployment successful!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: ğŸ”” Notify Production Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          fields: repo,message,commit,author
          text: 'ğŸš¨ Production deployment failed and rolled back!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # ============================================
  # POST-DEPLOYMENT VERIFICATION
  # ============================================
  post-deploy-verify:
    name: âœ… Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Health Check - Staging
        if: needs.deploy-staging.result == 'success'
        run: |
          echo "Verifying staging deployment..."
          for i in {1..5}; do
            if curl -f https://staging.toolboxai.solutions/health; then
              echo "Staging health check passed"
              break
            fi
            echo "Attempt $i failed, retrying..."
            sleep 30
          done

      - name: ğŸ” Health Check - Production
        if: needs.deploy-production.result == 'success'
        run: |
          echo "Verifying production deployment..."
          for i in {1..5}; do
            if curl -f https://toolboxai.solutions/health; then
              echo "Production health check passed"
              break
            fi
            echo "Attempt $i failed, retrying..."
            sleep 30
          done

      - name: ğŸ§ª Smoke Tests
        run: |
          # Run basic smoke tests
          python scripts/smoke-tests.py

      - name: ğŸ“Š Update Deployment Status
        run: |
          echo "Deployment verification completed successfully"

  # ============================================
  # CLEANUP
  # ============================================
  cleanup:
    name: ğŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [setup, build, test, security, deploy-staging, deploy-production]
    if: always()
    steps:
      - name: ğŸ—‘ï¸ Clean Up Docker Build Cache
        run: |
          docker builder prune -f --filter "until=24h"
          docker image prune -f --filter "until=24h"

      - name: ğŸ“ Deployment Summary
        run: |
          echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.setup.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Status**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests Status**: ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Scan**: ${{ needs.security.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging Deploy**: ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Production Deploy**: ${{ needs.deploy-production.result }}" >> $GITHUB_STEP_SUMMARY