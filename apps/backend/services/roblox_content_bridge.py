"""
Roblox Content Pipeline Bridge
Connects the enhanced content generation pipeline to Roblox Studio

This module transforms AI-generated content from the enhanced pipeline
into Roblox-compatible formats including Luau scripts, models, and assets.
"""

import asyncio
import json
import logging
import re
import uuid
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
from dataclasses import dataclass, field

import httpx
from pydantic import BaseModel, Field, field_validator
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

# Import our Week 2 components
from core.agents.enhanced_content_pipeline import (
    EnhancedContentPipeline,
    PipelineState,
    PipelineStage,
    ContentRequest
)
from core.agents.content_quality_validator import (
    ContentQualityValidator,
    ValidationReport,
    QualityDimension
)
from core.agents.adaptive_learning_engine import (
    AdaptiveLearningEngine,
    LearningProfile,
    DifficultyLevel
)
from core.agents.multi_modal_generator import (
    MultiModalGenerator,
    ContentModality,
    GeneratedContent
)
from apps.backend.services.websocket_pipeline_manager import (
    websocket_pipeline_manager
)
from database.models import (
    EnhancedContentGeneration,
    ContentQualityMetrics,
    LearningProfiles
)
from database.connection import get_async_session

logger = logging.getLogger(__name__)


class RobloxAssetType(str, Enum):
    """Types of assets that can be generated for Roblox"""
    SCRIPT = "Script"
    LOCAL_SCRIPT = "LocalScript"
    MODULE_SCRIPT = "ModuleScript"
    MODEL = "Model"
    PART = "Part"
    GUI = "ScreenGui"
    SOUND = "Sound"
    TEXTURE = "Texture"
    ANIMATION = "Animation"
    PARTICLE_EMITTER = "ParticleEmitter"
    TERRAIN = "Terrain"


class RobloxContentType(str, Enum):
    """Types of educational content for Roblox"""
    LESSON = "lesson"
    QUIZ = "quiz"
    INTERACTIVE_ACTIVITY = "interactive_activity"
    SIMULATION = "simulation"
    PUZZLE = "puzzle"
    TUTORIAL = "tutorial"
    SANDBOX = "sandbox"
    ASSESSMENT = "assessment"


@dataclass
class RobloxAsset:
    """Represents a single Roblox asset"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    type: RobloxAssetType = RobloxAssetType.SCRIPT
    content: str = ""
    properties: Dict[str, Any] = field(default_factory=dict)
    parent_path: str = "game.Workspace"
    metadata: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)


class LuauScriptGenerator:
    """Generates Luau scripts from AI content"""

    def __init__(self):
        self.templates = self._load_templates()
        self.validators = self._setup_validators()

    def _load_templates(self) -> Dict[str, str]:
        """Load Luau script templates"""
        return {
            "server_script": """--!strict
-- Generated by ToolboxAI Enhanced Pipeline
-- {title}
-- {description}

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

{imports}

local {module_name} = {{}}
{module_name}.__index = {module_name}

{properties}

function {module_name}.new({parameters})
    local self = setmetatable({{}}, {module_name})
    {initialization}
    return self
end

{methods}

{main_logic}

return {module_name}
""",
            "local_script": """--!strict
-- Generated by ToolboxAI Enhanced Pipeline
-- {title}

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

{imports}

{ui_setup}

{event_handlers}

{main_logic}
""",
            "module_script": """--!strict
-- Generated by ToolboxAI Enhanced Pipeline
-- {title}

local {module_name} = {{}}

{constants}

{private_functions}

{public_functions}

return {module_name}
"""
        }

    def _setup_validators(self) -> Dict[str, Any]:
        """Set up Luau syntax validators"""
        return {
            "keywords": [
                "local", "function", "end", "if", "then", "else", "elseif",
                "for", "while", "do", "repeat", "until", "return", "break",
                "continue", "and", "or", "not", "nil", "true", "false"
            ],
            "reserved_globals": [
                "game", "workspace", "script", "shared", "plugin",
                "_G", "_VERSION", "tick", "time", "wait"
            ]
        }

    async def generate_script(
        self,
        content: Dict[str, Any],
        script_type: RobloxAssetType
    ) -> RobloxAsset:
        """Generate a Luau script from AI content"""

        # Select appropriate template
        if script_type == RobloxAssetType.SCRIPT:
            template = self.templates["server_script"]
        elif script_type == RobloxAssetType.LOCAL_SCRIPT:
            template = self.templates["local_script"]
        else:
            template = self.templates["module_script"]

        # Extract content components
        title = content.get("title", "Generated Script")
        description = content.get("description", "")
        logic = content.get("logic", "")

        # Convert Python-like logic to Luau
        luau_code = await self._convert_to_luau(logic)

        # Generate module name from title
        module_name = self._sanitize_module_name(title)

        # Fill template
        script_content = template.format(
            title=title,
            description=description,
            module_name=module_name,
            imports=await self._generate_imports(content),
            properties=await self._generate_properties(content),
            parameters=await self._generate_parameters(content),
            initialization=await self._generate_initialization(content),
            methods=await self._generate_methods(content),
            main_logic=luau_code,
            ui_setup="",  # Will be filled for GUI scripts
            event_handlers="",  # Will be filled for interactive scripts
            constants="",
            private_functions="",
            public_functions=""
        )

        # Validate generated script
        is_valid, errors = await self._validate_luau_syntax(script_content)
        if not is_valid:
            logger.warning(f"Generated script has syntax issues: {errors}")
            script_content = await self._fix_syntax_errors(script_content, errors)

        return RobloxAsset(
            name=f"{module_name}.lua",
            type=script_type,
            content=script_content,
            properties={
                "Disabled": False,
                "RunContext": "Server" if script_type == RobloxAssetType.SCRIPT else "Client"
            },
            metadata={
                "generated_at": datetime.now(timezone.utc).isoformat(),
                "ai_model": "enhanced_pipeline",
                "quality_score": content.get("quality_score", 0)
            }
        )

    async def _convert_to_luau(self, logic: str) -> str:
        """Convert Python-like logic to Luau syntax"""
        if not logic:
            return "-- Main logic implementation"

        # Basic conversions
        conversions = {
            "def ": "function ",
            "elif ": "elseif ",
            "None": "nil",
            "True": "true",
            "False": "false",
            "#": "--",
            "!=": "~=",
            "//": "--",
            "import ": "local ",
            "from ": "local ",
            " in ": " in pairs(",
            "range(": "for i = 1, ",
            "len(": "#",
            ".append(": ":Insert(",
            "print(": "print(",
            "str(": "tostring(",
            "int(": "tonumber(",
            "float(": "tonumber(",
        }

        luau_code = logic
        for py_syntax, lua_syntax in conversions.items():
            luau_code = luau_code.replace(py_syntax, lua_syntax)

        # Add 'local' to variable declarations
        lines = luau_code.split('\n')
        processed_lines = []
        for line in lines:
            if '=' in line and not line.strip().startswith('local') and not line.strip().startswith('--'):
                # Check if it's a variable assignment
                if not any(keyword in line for keyword in ['function', 'if', 'then', 'else']):
                    line = 'local ' + line.strip()
            processed_lines.append(line)

        return '\n'.join(processed_lines)

    async def _validate_luau_syntax(self, script: str) -> Tuple[bool, List[str]]:
        """Validate Luau syntax"""
        errors = []

        # Check for balanced brackets
        open_brackets = script.count('{')
        close_brackets = script.count('}')
        if open_brackets != close_brackets:
            errors.append(f"Unbalanced brackets: {open_brackets} open, {close_brackets} close")

        # Check for balanced parentheses
        open_parens = script.count('(')
        close_parens = script.count(')')
        if open_parens != close_parens:
            errors.append(f"Unbalanced parentheses: {open_parens} open, {close_parens} close")

        # Check for 'end' statements
        function_count = script.count('function')
        if_count = script.count('if ') + script.count('if(')
        for_count = script.count('for ')
        while_count = script.count('while ')
        do_count = script.count('do\n') + script.count('do ')

        expected_ends = function_count + if_count + for_count + while_count + do_count
        actual_ends = script.count('end')

        if expected_ends != actual_ends:
            errors.append(f"Mismatched 'end' statements: expected {expected_ends}, found {actual_ends}")

        return len(errors) == 0, errors

    async def _fix_syntax_errors(self, script: str, errors: List[str]) -> str:
        """Attempt to fix common syntax errors"""
        # This is a simple implementation - in production, use more sophisticated fixing
        for error in errors:
            if "Unbalanced brackets" in error:
                # Add missing closing brackets
                script += "\n}"
            elif "Mismatched 'end'" in error:
                # Add missing end statements
                script += "\nend"

        return script

    def _sanitize_module_name(self, title: str) -> str:
        """Convert title to valid Luau module name"""
        # Remove special characters and convert to PascalCase
        words = re.findall(r'\w+', title)
        return ''.join(word.capitalize() for word in words)

    async def _generate_imports(self, content: Dict[str, Any]) -> str:
        """Generate import statements"""
        imports = []
        if content.get("uses_datastore"):
            imports.append("local DataStoreService = game:GetService('DataStoreService')")
        if content.get("uses_http"):
            imports.append("local HttpService = game:GetService('HttpService')")
        if content.get("uses_messaging"):
            imports.append("local MessagingService = game:GetService('MessagingService')")
        return '\n'.join(imports)

    async def _generate_properties(self, content: Dict[str, Any]) -> str:
        """Generate class properties"""
        properties = content.get("properties", {})
        if not properties:
            return ""

        prop_lines = []
        for name, value in properties.items():
            if isinstance(value, str):
                prop_lines.append(f'{module_name}.{name} = "{value}"')
            elif isinstance(value, bool):
                prop_lines.append(f'{module_name}.{name} = {"true" if value else "false"}')
            else:
                prop_lines.append(f'{module_name}.{name} = {value}')

        return '\n'.join(prop_lines)

    async def _generate_parameters(self, content: Dict[str, Any]) -> str:
        """Generate constructor parameters"""
        params = content.get("constructor_params", [])
        return ', '.join(params) if params else ""

    async def _generate_initialization(self, content: Dict[str, Any]) -> str:
        """Generate initialization code"""
        init_code = content.get("initialization", [])
        if not init_code:
            return "-- No initialization required"
        return '\n    '.join(init_code)

    async def _generate_methods(self, content: Dict[str, Any]) -> str:
        """Generate class methods"""
        methods = content.get("methods", [])
        if not methods:
            return ""

        method_code = []
        for method in methods:
            method_code.append(f"""
function {module_name}:{method['name']}({', '.join(method.get('params', []))})
    {method.get('body', '-- Method implementation')}
end""")

        return '\n'.join(method_code)


class RobloxAssetConverter:
    """Converts various content types to Roblox assets"""

    def __init__(self):
        self.script_generator = LuauScriptGenerator()
        self.asset_templates = self._load_asset_templates()

    def _load_asset_templates(self) -> Dict[str, Any]:
        """Load asset generation templates"""
        return {
            "part": {
                "ClassName": "Part",
                "Properties": {
                    "Anchored": True,
                    "CanCollide": True,
                    "Material": "Plastic",
                    "Size": [4, 1, 2],
                    "Position": [0, 5, 0],
                    "BrickColor": "Medium stone grey"
                }
            },
            "gui": {
                "ClassName": "ScreenGui",
                "Properties": {
                    "ResetOnSpawn": False,
                    "DisplayOrder": 0
                }
            },
            "sound": {
                "ClassName": "Sound",
                "Properties": {
                    "Volume": 0.5,
                    "Pitch": 1,
                    "Looped": False
                }
            }
        }

    async def convert_to_roblox_asset(
        self,
        content: GeneratedContent,
        asset_type: RobloxAssetType
    ) -> RobloxAsset:
        """Convert generated content to Roblox asset"""

        if asset_type in [RobloxAssetType.SCRIPT, RobloxAssetType.LOCAL_SCRIPT, RobloxAssetType.MODULE_SCRIPT]:
            # Generate Luau script
            return await self.script_generator.generate_script(
                content.to_dict(),
                asset_type
            )

        elif asset_type == RobloxAssetType.MODEL:
            return await self._create_model_asset(content)

        elif asset_type == RobloxAssetType.GUI:
            return await self._create_gui_asset(content)

        elif asset_type == RobloxAssetType.SOUND:
            return await self._create_sound_asset(content)

        elif asset_type == RobloxAssetType.PART:
            return await self._create_part_asset(content)

        else:
            # Default to script
            return await self.script_generator.generate_script(
                content.to_dict(),
                RobloxAssetType.SCRIPT
            )

    async def _create_model_asset(self, content: GeneratedContent) -> RobloxAsset:
        """Create a model asset"""
        model_data = {
            "ClassName": "Model",
            "Name": content.title or "GeneratedModel",
            "Children": []
        }

        # Add parts based on content
        if content.visual_specs:
            for spec in content.visual_specs.get("components", []):
                part = await self._create_part_from_spec(spec)
                model_data["Children"].append(part)

        return RobloxAsset(
            name=model_data["Name"],
            type=RobloxAssetType.MODEL,
            content=json.dumps(model_data, indent=2),
            properties={"PrimaryPart": None},
            metadata={"component_count": len(model_data["Children"])}
        )

    async def _create_part_from_spec(self, spec: Dict[str, Any]) -> Dict[str, Any]:
        """Create a part from specification"""
        part = self.asset_templates["part"].copy()

        # Update properties from spec
        if "size" in spec:
            part["Properties"]["Size"] = spec["size"]
        if "position" in spec:
            part["Properties"]["Position"] = spec["position"]
        if "color" in spec:
            part["Properties"]["BrickColor"] = spec["color"]
        if "material" in spec:
            part["Properties"]["Material"] = spec["material"]

        return part

    async def _create_gui_asset(self, content: GeneratedContent) -> RobloxAsset:
        """Create a GUI asset"""
        gui_data = self.asset_templates["gui"].copy()
        gui_data["Name"] = content.title or "GeneratedGUI"
        gui_data["Children"] = []

        # Create GUI elements based on content
        if content.interactive_elements:
            for element in content.interactive_elements:
                gui_element = await self._create_gui_element(element)
                gui_data["Children"].append(gui_element)

        return RobloxAsset(
            name=gui_data["Name"],
            type=RobloxAssetType.GUI,
            content=json.dumps(gui_data, indent=2),
            parent_path="game.Players.LocalPlayer.PlayerGui",
            metadata={"element_count": len(gui_data["Children"])}
        )

    async def _create_gui_element(self, element: Dict[str, Any]) -> Dict[str, Any]:
        """Create a GUI element"""
        element_type = element.get("type", "TextLabel")

        gui_element = {
            "ClassName": element_type,
            "Properties": {
                "Size": element.get("size", [200, 50]),
                "Position": element.get("position", [0, 0]),
                "Text": element.get("text", ""),
                "TextScaled": True,
                "BackgroundColor3": element.get("bg_color", [255, 255, 255]),
                "TextColor3": element.get("text_color", [0, 0, 0])
            }
        }

        return gui_element

    async def _create_sound_asset(self, content: GeneratedContent) -> RobloxAsset:
        """Create a sound asset"""
        sound_data = self.asset_templates["sound"].copy()
        sound_data["Name"] = content.title or "GeneratedSound"

        if content.audio_narration:
            sound_data["Properties"]["SoundId"] = content.audio_narration.get("sound_id", "")
            sound_data["Properties"]["Volume"] = content.audio_narration.get("volume", 0.5)
            sound_data["Properties"]["Pitch"] = content.audio_narration.get("pitch", 1.0)

        return RobloxAsset(
            name=sound_data["Name"],
            type=RobloxAssetType.SOUND,
            content=json.dumps(sound_data, indent=2),
            parent_path="game.Workspace",
            metadata={"duration": content.audio_narration.get("duration", 0)}
        )

    async def _create_part_asset(self, content: GeneratedContent) -> RobloxAsset:
        """Create a part asset"""
        part_data = self.asset_templates["part"].copy()
        part_data["Name"] = content.title or "GeneratedPart"

        # Update properties from content
        if content.visual_specs:
            specs = content.visual_specs
            if "dimensions" in specs:
                part_data["Properties"]["Size"] = specs["dimensions"]
            if "material" in specs:
                part_data["Properties"]["Material"] = specs["material"]
            if "color" in specs:
                part_data["Properties"]["BrickColor"] = specs["color"]

        return RobloxAsset(
            name=part_data["Name"],
            type=RobloxAssetType.PART,
            content=json.dumps(part_data, indent=2),
            parent_path="game.Workspace",
            metadata={"physics_enabled": True}
        )


class RobloxContentBridge:
    """Main bridge between enhanced content pipeline and Roblox"""

    def __init__(self):
        self.pipeline = EnhancedContentPipeline()
        self.validator = ContentQualityValidator()
        self.learning_engine = AdaptiveLearningEngine()
        self.generator = MultiModalGenerator()
        self.asset_converter = RobloxAssetConverter()
        self.cache = {}

    async def generate_roblox_content(
        self,
        request: ContentRequest,
        content_type: RobloxContentType,
        user_id: str,
        session: AsyncSession
    ) -> Dict[str, Any]:
        """Generate Roblox content using enhanced pipeline"""

        # Create pipeline ID
        pipeline_id = f"roblox_{uuid.uuid4().hex[:8]}"

        # Initialize WebSocket tracking
        await websocket_pipeline_manager.update_pipeline_state(
            pipeline_id=pipeline_id,
            stage=PipelineStage.IDEATION,
            progress=0,
            message="Starting Roblox content generation"
        )

        try:
            # Get user's learning profile
            learning_profile = await self.learning_engine.get_learning_profile(
                user_id, session
            )

            # Adjust request based on learning profile
            if learning_profile:
                request = await self._personalize_request(request, learning_profile)

            # Run enhanced content pipeline
            await websocket_pipeline_manager.update_pipeline_state(
                pipeline_id=pipeline_id,
                stage=PipelineStage.GENERATION,
                progress=20,
                message="Generating educational content"
            )

            pipeline_result = await self.pipeline.run(request, user_id, session)

            # Validate content for Roblox compatibility
            await websocket_pipeline_manager.update_pipeline_state(
                pipeline_id=pipeline_id,
                stage=PipelineStage.VALIDATION,
                progress=40,
                message="Validating Roblox compatibility"
            )

            validation_report = await self._validate_for_roblox(pipeline_result)

            if validation_report.overall_score < 0.7:
                # Content needs improvement
                pipeline_result = await self._improve_content(
                    pipeline_result,
                    validation_report
                )

            # Convert to Roblox assets
            await websocket_pipeline_manager.update_pipeline_state(
                pipeline_id=pipeline_id,
                stage=PipelineStage.OPTIMIZATION,
                progress=60,
                message="Converting to Roblox assets"
            )

            roblox_assets = await self._convert_to_roblox_assets(
                pipeline_result,
                content_type
            )

            # Package for deployment
            await websocket_pipeline_manager.update_pipeline_state(
                pipeline_id=pipeline_id,
                stage=PipelineStage.DEPLOYMENT,
                progress=80,
                message="Packaging for Roblox Studio"
            )

            package = await self._package_assets(roblox_assets)

            # Save to database
            await self._save_generation(
                pipeline_id=pipeline_id,
                user_id=user_id,
                content=package,
                session=session
            )

            # Complete pipeline
            await websocket_pipeline_manager.send_completion(
                pipeline_id=pipeline_id,
                result={
                    "success": True,
                    "assets": len(roblox_assets),
                    "package_id": package["id"]
                },
                metrics={
                    "generation_time": package.get("generation_time", 0),
                    "quality_score": validation_report.overall_score
                }
            )

            return {
                "success": True,
                "pipeline_id": pipeline_id,
                "package": package,
                "assets": roblox_assets,
                "validation": validation_report.to_dict(),
                "metadata": {
                    "content_type": content_type.value,
                    "generated_at": datetime.now(timezone.utc).isoformat(),
                    "quality_score": validation_report.overall_score
                }
            }

        except Exception as e:
            logger.error(f"Error in Roblox content generation: {e}")
            await websocket_pipeline_manager.send_error(
                pipeline_id=pipeline_id,
                error_message=str(e),
                error_details={"type": type(e).__name__}
            )
            raise

    async def _personalize_request(
        self,
        request: ContentRequest,
        profile: LearningProfile
    ) -> ContentRequest:
        """Personalize content request based on learning profile"""

        # Adjust difficulty
        if profile.current_level:
            request.difficulty_level = profile.current_level

        # Add learning preferences
        if profile.learning_style:
            request.metadata["learning_style"] = profile.learning_style

        # Add previous performance data
        request.metadata["performance_history"] = profile.performance_metrics

        return request

    async def _validate_for_roblox(
        self,
        content: Dict[str, Any]
    ) -> ValidationReport:
        """Validate content for Roblox compatibility"""

        # Run standard validation
        report = await self.validator.validate_content(
            content=content,
            content_type="roblox_experience",
            target_age=content.get("target_age", 10)
        )

        # Add Roblox-specific checks
        roblox_issues = []

        # Check for inappropriate content
        if await self._contains_inappropriate_content(content):
            roblox_issues.append({
                "dimension": "safety",
                "issue": "Content may violate Roblox community standards",
                "severity": "high"
            })

        # Check script complexity
        if await self._is_too_complex(content):
            roblox_issues.append({
                "dimension": "technical",
                "issue": "Script complexity may cause performance issues",
                "severity": "medium"
            })

        # Check asset limits
        if await self._exceeds_asset_limits(content):
            roblox_issues.append({
                "dimension": "technical",
                "issue": "Content exceeds Roblox asset limits",
                "severity": "high"
            })

        # Add issues to report
        report.issues.extend(roblox_issues)

        # Recalculate score if issues were added
        if roblox_issues:
            report.overall_score *= 0.9  # Reduce score for Roblox issues

        return report

    async def _contains_inappropriate_content(self, content: Dict[str, Any]) -> bool:
        """Check for content that violates Roblox standards"""
        # Simplified check - in production, use more sophisticated filtering
        inappropriate_terms = [
            "violence", "adult", "gambling", "dating"
        ]

        content_text = json.dumps(content).lower()
        return any(term in content_text for term in inappropriate_terms)

    async def _is_too_complex(self, content: Dict[str, Any]) -> bool:
        """Check if content is too complex for Roblox"""
        # Check script length
        script_content = content.get("script_content", "")
        return len(script_content) > 10000  # Lines of code limit

    async def _exceeds_asset_limits(self, content: Dict[str, Any]) -> bool:
        """Check if content exceeds Roblox asset limits"""
        # Check number of parts
        part_count = content.get("part_count", 0)
        if part_count > 1000:
            return True

        # Check texture size
        texture_size = content.get("texture_size", 0)
        if texture_size > 1024 * 1024:  # 1MB limit
            return True

        return False

    async def _improve_content(
        self,
        content: Dict[str, Any],
        validation_report: ValidationReport
    ) -> Dict[str, Any]:
        """Improve content based on validation report"""

        for issue in validation_report.issues:
            if issue["severity"] == "high":
                # Apply fixes based on issue type
                if issue["dimension"] == "safety":
                    content = await self._sanitize_content(content)
                elif issue["dimension"] == "technical":
                    content = await self._optimize_content(content)
                elif issue["dimension"] == "educational":
                    content = await self._enhance_educational_value(content)

        return content

    async def _sanitize_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """Sanitize content for Roblox standards"""
        # Remove inappropriate content
        # This is a simplified implementation
        return content

    async def _optimize_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """Optimize content for performance"""
        # Reduce complexity
        # This is a simplified implementation
        return content

    async def _enhance_educational_value(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """Enhance educational value of content"""
        # Add educational elements
        # This is a simplified implementation
        return content

    async def _convert_to_roblox_assets(
        self,
        content: Dict[str, Any],
        content_type: RobloxContentType
    ) -> List[RobloxAsset]:
        """Convert content to Roblox assets"""

        assets = []

        # Create main script
        main_script = await self.asset_converter.convert_to_roblox_asset(
            GeneratedContent.from_dict(content),
            RobloxAssetType.SCRIPT
        )
        assets.append(main_script)

        # Create UI if needed
        if content_type in [RobloxContentType.QUIZ, RobloxContentType.TUTORIAL]:
            gui_asset = await self.asset_converter.convert_to_roblox_asset(
                GeneratedContent.from_dict(content),
                RobloxAssetType.GUI
            )
            assets.append(gui_asset)

        # Create models if needed
        if content.get("models"):
            for model_data in content["models"]:
                model_asset = await self.asset_converter.convert_to_roblox_asset(
                    GeneratedContent.from_dict(model_data),
                    RobloxAssetType.MODEL
                )
                assets.append(model_asset)

        # Create sounds if needed
        if content.get("audio"):
            for audio_data in content["audio"]:
                sound_asset = await self.asset_converter.convert_to_roblox_asset(
                    GeneratedContent.from_dict(audio_data),
                    RobloxAssetType.SOUND
                )
                assets.append(sound_asset)

        return assets

    async def _package_assets(self, assets: List[RobloxAsset]) -> Dict[str, Any]:
        """Package assets for delivery to Roblox Studio"""

        package_id = str(uuid.uuid4())

        package = {
            "id": package_id,
            "version": "1.0.0",
            "created_at": datetime.now(timezone.utc).isoformat(),
            "assets": [],
            "manifest": {
                "entry_point": None,
                "dependencies": [],
                "metadata": {}
            }
        }

        for asset in assets:
            asset_data = {
                "id": asset.id,
                "name": asset.name,
                "type": asset.type.value,
                "content": asset.content,
                "properties": asset.properties,
                "parent_path": asset.parent_path,
                "metadata": asset.metadata
            }
            package["assets"].append(asset_data)

            # Set entry point
            if asset.type == RobloxAssetType.SCRIPT and not package["manifest"]["entry_point"]:
                package["manifest"]["entry_point"] = asset.id

        # Calculate package size
        package_size = sum(len(asset.content) for asset in assets)
        package["manifest"]["metadata"]["size"] = package_size
        package["manifest"]["metadata"]["asset_count"] = len(assets)

        return package

    async def _save_generation(
        self,
        pipeline_id: str,
        user_id: str,
        content: Dict[str, Any],
        session: AsyncSession
    ) -> None:
        """Save generation to database"""

        generation = EnhancedContentGeneration(
            pipeline_id=pipeline_id,
            user_id=user_id,
            content_type="roblox",
            enhanced_content=content,
            status="completed",
            quality_score=content.get("quality_score", 0),
            generation_time=content.get("generation_time", 0),
            metadata={
                "asset_count": len(content.get("assets", [])),
                "package_id": content.get("id")
            }
        )

        session.add(generation)
        await session.commit()

    async def deploy_to_studio(
        self,
        package_id: str,
        studio_session_id: str
    ) -> Dict[str, Any]:
        """Deploy package directly to Roblox Studio"""

        # This would integrate with Roblox Studio plugin
        # For now, return package info for manual deployment

        return {
            "success": True,
            "package_id": package_id,
            "deployment_method": "manual",
            "instructions": [
                "1. Open the ToolboxAI plugin in Roblox Studio",
                "2. Click 'Import Package'",
                f"3. Enter package ID: {package_id}",
                "4. Click 'Deploy' to add assets to your game"
            ]
        }


# Initialize global instance
roblox_content_bridge = RobloxContentBridge()