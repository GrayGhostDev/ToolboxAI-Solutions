name: Release Automation

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test suite (not recommended)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version_bump: ${{ steps.check.outputs.version_bump }}
      release_notes: ${{ steps.check.outputs.release_notes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN || github.token }}
      
      - name: Check if release is needed
        id: check
        run: |
          # Check if this is a manual release
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "version_bump=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
            echo "Manual release triggered"
            exit 0
          fi
          
          # Check if this is a tag push
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "version_bump=tag" >> $GITHUB_OUTPUT
            echo "Tag-based release"
            exit 0
          fi
          
          # For main branch pushes, analyze commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last tag: $LAST_TAG"
          
          # Get commits since last tag
          COMMITS=$(git log ${LAST_TAG}..HEAD --oneline)
          
          if [ -z "$COMMITS" ]; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No new commits since last release"
            exit 0
          fi
          
          # Analyze commit messages for conventional commits
          MAJOR_CHANGES=0
          MINOR_CHANGES=0
          PATCH_CHANGES=0
          
          while IFS= read -r commit; do
            echo "Analyzing commit: $commit"
            
            if echo "$commit" | grep -qE "^[a-f0-9]+ (feat|feature)(\(.+\))?!:"; then
              MAJOR_CHANGES=$((MAJOR_CHANGES + 1))
            elif echo "$commit" | grep -qE "^[a-f0-9]+ BREAKING CHANGE:"; then
              MAJOR_CHANGES=$((MAJOR_CHANGES + 1))
            elif echo "$commit" | grep -qE "^[a-f0-9]+ (feat|feature)(\(.+\))?:"; then
              MINOR_CHANGES=$((MINOR_CHANGES + 1))
            elif echo "$commit" | grep -qE "^[a-f0-9]+ (fix|bugfix|perf|performance)(\(.+\))?:"; then
              PATCH_CHANGES=$((PATCH_CHANGES + 1))
            fi
          done <<< "$COMMITS"
          
          echo "Changes detected - Major: $MAJOR_CHANGES, Minor: $MINOR_CHANGES, Patch: $PATCH_CHANGES"
          
          # Determine version bump
          if [ $MAJOR_CHANGES -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "version_bump=major" >> $GITHUB_OUTPUT
          elif [ $MINOR_CHANGES -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "version_bump=minor" >> $GITHUB_OUTPUT
          elif [ $PATCH_CHANGES -gt 0 ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "version_bump=patch" >> $GITHUB_OUTPUT
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No releasable changes found"
          fi
      
      - name: Generate release notes
        if: steps.check.outputs.should_release == 'true'
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          # Generate changelog
          cat > release-notes.md << 'EOF'
          ## What's Changed
          
          EOF
          
          # Add features
          echo "### âœ¨ New Features" >> release-notes.md
          git log ${LAST_TAG}..HEAD --oneline --grep="^feat\|^feature" | sed 's/^[a-f0-9]* /- /' >> release-notes.md || true
          
          # Add fixes
          echo "" >> release-notes.md
          echo "### ðŸ› Bug Fixes" >> release-notes.md
          git log ${LAST_TAG}..HEAD --oneline --grep="^fix\|^bugfix" | sed 's/^[a-f0-9]* /- /' >> release-notes.md || true
          
          # Add performance improvements
          echo "" >> release-notes.md
          echo "### âš¡ Performance Improvements" >> release-notes.md
          git log ${LAST_TAG}..HEAD --oneline --grep="^perf\|^performance" | sed 's/^[a-f0-9]* /- /' >> release-notes.md || true
          
          # Add documentation updates
          echo "" >> release-notes.md
          echo "### ðŸ“š Documentation" >> release-notes.md
          git log ${LAST_TAG}..HEAD --oneline --grep="^docs" | sed 's/^[a-f0-9]* /- /' >> release-notes.md || true
          
          # Add other changes
          echo "" >> release-notes.md
          echo "### ðŸ”§ Other Changes" >> release-notes.md
          git log ${LAST_TAG}..HEAD --oneline --grep="^chore\|^style\|^refactor\|^test" | sed 's/^[a-f0-9]* /- /' >> release-notes.md || true
          
          # Add breaking changes if any
          BREAKING_CHANGES=$(git log ${LAST_TAG}..HEAD --grep="BREAKING CHANGE" --oneline)
          if [ -n "$BREAKING_CHANGES" ]; then
            echo "" >> release-notes.md
            echo "### âš ï¸ BREAKING CHANGES" >> release-notes.md
            echo "$BREAKING_CHANGES" | sed 's/^[a-f0-9]* /- /' >> release-notes.md
          fi
          
          # Add contributors
          echo "" >> release-notes.md
          echo "### ðŸ‘¥ Contributors" >> release-notes.md
          git log ${LAST_TAG}..HEAD --pretty=format:"- @%an" | sort -u >> release-notes.md
          
          # Store release notes
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_ENV
          cat release-notes.md >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

  run-tests:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.should_release == 'true' && github.event.inputs.skip_tests != 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
          npm install
          cd API/Dashboard && npm install
      
      - name: Run Python tests
        run: |
          pytest tests/unit/ --maxfail=1 -q
      
      - name: Run Node.js tests
        run: |
          npm test
          cd API/Dashboard && npm test

  calculate-version:
    runs-on: ubuntu-latest
    needs: [detect-changes, run-tests]
    if: ${{ always() && needs.detect-changes.outputs.should_release == 'true' && (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped') }}
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      current_version: ${{ steps.version.outputs.current_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Calculate new version
        id: version
        run: |
          # Get current version from git tags
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${CURRENT_VERSION#v}  # Remove 'v' prefix
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Determine version bump
          BUMP_TYPE="${{ needs.detect-changes.outputs.version_bump }}"
          if [ "${{ github.event.inputs.release_type }}" != "" ]; then
            BUMP_TYPE="${{ github.event.inputs.release_type }}"
          fi
          
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            tag)
              # For tag-based releases, extract version from tag
              NEW_VERSION="${{ github.ref_name }}"
              NEW_VERSION=${NEW_VERSION#v}  # Remove 'v' prefix
              echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version bump: $CURRENT_VERSION -> $NEW_VERSION (type: $BUMP_TYPE)"

  build-release-assets:
    runs-on: ubuntu-latest
    needs: [detect-changes, calculate-version]
    if: ${{ always() && needs.detect-changes.outputs.should_release == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install build dependencies
        run: |
          pip install build wheel setuptools
          npm install
      
      - name: Update version in files
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.new_version }}"
          
          # Update package.json version
          jq ".version = \"$NEW_VERSION\"" package.json > package.json.tmp && mv package.json.tmp package.json
          
          # Update Dashboard package.json
          cd API/Dashboard
          jq ".version = \"$NEW_VERSION\"" package.json > package.json.tmp && mv package.json.tmp package.json
          cd ../..
          
          # Update Python version if setup.py exists
          if [ -f setup.py ]; then
            sed -i "s/version=['\"][^'\"]*['\"]/version='$NEW_VERSION'/g" setup.py
          fi
          
          # Create version file
          echo "$NEW_VERSION" > VERSION
      
      - name: Build Python packages
        run: |
          # Create source distribution
          python -m build --sdist --outdir dist/
          
          # Create requirements bundle
          pip freeze > requirements-frozen.txt
      
      - name: Build Dashboard
        run: |
          cd API/Dashboard
          npm run build
          
          # Create distribution archive
          tar -czf ../dashboard-dist.tar.gz dist/
      
      - name: Create release bundle
        run: |
          mkdir -p release-assets
          
          # Copy built assets
          cp dist/*.tar.gz release-assets/ || true
          cp API/dashboard-dist.tar.gz release-assets/ || true
          cp requirements-frozen.txt release-assets/
          cp VERSION release-assets/
          
          # Create installation script
          cat > release-assets/install.sh << 'EOF'
          #!/bin/bash
          # ToolboxAI Roblox Environment Installation Script
          
          set -e
          
          echo "Installing ToolboxAI Roblox Environment..."
          
          # Install Python dependencies
          pip install -r requirements-frozen.txt
          
          # Extract Dashboard
          tar -xzf dashboard-dist.tar.gz
          
          echo "Installation complete!"
          echo "Version: $(cat VERSION)"
          EOF
          
          chmod +x release-assets/install.sh
          
          # Create checksums
          cd release-assets
          sha256sum * > checksums.txt
      
      - name: Upload release assets
        uses: actions/upload-artifact@v3
        with:
          name: release-assets
          path: release-assets/

  build-docker-images:
    runs-on: ubuntu-latest
    needs: [detect-changes, calculate-version]
    if: ${{ always() && needs.detect-changes.outputs.should_release == 'true' }}
    strategy:
      matrix:
        image: [api, mcp, agents]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: toolboxai/roblox-${{ matrix.image }}
          tags: |
            type=raw,value=latest
            type=raw,value=v${{ needs.calculate-version.outputs.new_version }}
            type=raw,value=${{ needs.calculate-version.outputs.new_version }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile.${{ matrix.image }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=v${{ needs.calculate-version.outputs.new_version }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

  create-github-release:
    runs-on: ubuntu-latest
    needs: [detect-changes, calculate-version, build-release-assets, build-docker-images]
    if: ${{ always() && needs.detect-changes.outputs.should_release == 'true' && (needs.build-release-assets.result == 'success' || needs.build-release-assets.result == 'skipped') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN || github.token }}
      
      - name: Download release assets
        uses: actions/download-artifact@v3
        with:
          name: release-assets
          path: release-assets/
      
      - name: Create and push tag
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        run: |
          NEW_VERSION="v${{ needs.calculate-version.outputs.new_version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"
      
      - name: Create GitHub Release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const newVersion = 'v${{ needs.calculate-version.outputs.new_version }}';
            const isPrerelease = '${{ github.event.inputs.prerelease }}' === 'true';
            
            // Create release
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: newVersion,
              name: `ToolboxAI Roblox Environment ${newVersion}`,
              body: `${{ env.RELEASE_NOTES }}`,
              draft: false,
              prerelease: isPrerelease
            });
            
            console.log(`Created release: ${release.html_url}`);
            
            // Upload assets
            const assetDir = 'release-assets';
            const files = fs.readdirSync(assetDir);
            
            for (const file of files) {
              const filePath = path.join(assetDir, file);
              const fileContent = fs.readFileSync(filePath);
              
              console.log(`Uploading ${file}...`);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                name: file,
                data: fileContent,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': fileContent.length,
                },
              });
            }
            
            console.log('All assets uploaded successfully');

  update-documentation:
    runs-on: ubuntu-latest
    needs: [create-github-release]
    if: ${{ always() && needs.create-github-release.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || github.token }}
      
      - name: Update changelog
        run: |
          NEW_VERSION="v${{ needs.calculate-version.outputs.new_version }}"
          
          # Create or update CHANGELOG.md
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Prepare new entry
          cat > changelog_entry.md << EOF
          ## [$NEW_VERSION] - $(date +%Y-%m-%d)
          
          ${{ env.RELEASE_NOTES }}
          
          EOF
          
          # Insert new entry after the header
          sed -i '/^All notable changes/r changelog_entry.md' CHANGELOG.md
          
          rm changelog_entry.md
      
      - name: Update version badges in README
        run: |
          NEW_VERSION="${{ needs.calculate-version.outputs.new_version }}"
          
          # Update version badge in README
          if [ -f README.md ]; then
            sed -i "s/version-[^-]*-blue/version-$NEW_VERSION-blue/g" README.md
            sed -i "s/v[0-9]\+\.[0-9]\+\.[0-9]\+/v$NEW_VERSION/g" README.md
          fi
      
      - name: Commit documentation updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git add CHANGELOG.md README.md
          
          if git diff --cached --quiet; then
            echo "No documentation changes to commit"
          else
            git commit -m "docs: update changelog and version badges for v${{ needs.calculate-version.outputs.new_version }} [skip ci]"
            git push origin main
          fi

  notify-release:
    runs-on: ubuntu-latest
    needs: [create-github-release, calculate-version]
    if: ${{ always() && needs.create-github-release.result == 'success' }}
    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            ðŸš€ New release published!
            
            **Version:** v${{ needs.calculate-version.outputs.new_version }}
            **Repository:** ${{ github.repository }}
            **Release Notes:** ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ needs.calculate-version.outputs.new_version }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      
      - name: Create deployment issue
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN || github.token }}
          script: |
            const newVersion = 'v${{ needs.calculate-version.outputs.new_version }}';
            
            const title = `Deploy ${newVersion} to production`;
            const body = `
            ## Deployment Checklist for ${newVersion}
            
            This release is ready for deployment to production.
            
            ### Pre-deployment
            - [ ] Review release notes
            - [ ] Verify all tests pass
            - [ ] Check staging deployment
            - [ ] Security scan clean
            
            ### Deployment
            - [ ] Deploy to production
            - [ ] Verify health checks
            - [ ] Run smoke tests
            - [ ] Monitor error rates
            
            ### Post-deployment
            - [ ] Verify all services operational
            - [ ] Update monitoring dashboards
            - [ ] Notify stakeholders
            
            **Release URL:** ${{ github.server_url }}/${{ github.repository }}/releases/tag/${newVersion}
            **Docker Images:** 
            - toolboxai/roblox-api:${newVersion}
            - toolboxai/roblox-mcp:${newVersion}
            - toolboxai/roblox-agents:${newVersion}
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'production', 'release']
            });

  release-summary:
    runs-on: ubuntu-latest
    needs: [detect-changes, calculate-version, run-tests, build-release-assets, build-docker-images, create-github-release, update-documentation, notify-release]
    if: always()
    steps:
      - name: Generate release summary
        run: |
          echo "# Release Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch/Tag:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.detect-changes.outputs.should_release }}" == "true" ]; then
            echo "## ðŸš€ Release Information" >> $GITHUB_STEP_SUMMARY
            echo "- **Version:** v${{ needs.calculate-version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Previous Version:** v${{ needs.calculate-version.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Type:** ${{ needs.detect-changes.outputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Pre-release:** ${{ github.event.inputs.prerelease || 'false' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "## âœ… Completed Tasks" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ needs.run-tests.result }}" == "success" ]; then
              echo "- âœ… Tests passed" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.run-tests.result }}" == "skipped" ]; then
              echo "- â­ï¸ Tests skipped" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ Tests failed" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.build-release-assets.result }}" == "success" ]; then
              echo "- âœ… Release assets built" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ Release assets failed" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.build-docker-images.result }}" == "success" ]; then
              echo "- âœ… Docker images published" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ Docker images failed" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.create-github-release.result }}" == "success" ]; then
              echo "- âœ… GitHub release created" >> $GITHUB_STEP_SUMMARY
              echo "  - **URL:** ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ needs.calculate-version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ GitHub release failed" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.update-documentation.result }}" == "success" ]; then
              echo "- âœ… Documentation updated" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ Documentation update failed" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.notify-release.result }}" == "success" ]; then
              echo "- âœ… Notifications sent" >> $GITHUB_STEP_SUMMARY
            else
              echo "- âŒ Notifications failed" >> $GITHUB_STEP_SUMMARY
            fi
            
          else
            echo "## â„¹ï¸ No Release Needed" >> $GITHUB_STEP_SUMMARY
            echo "No releasable changes were detected in the recent commits." >> $GITHUB_STEP_SUMMARY
          fi