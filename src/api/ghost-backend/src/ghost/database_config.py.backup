"""
Database Configuration and Multi-Database Support

Provides configuration for multiple databases used in the ToolboxAI Roblox Environment:
- Ghost Backend Database (PostgreSQL) - Main API and authentication
- Educational Dashboard Database (PostgreSQL) - Student/teacher data and progress
- Roblox Data Database (PostgreSQL) - Game wor    async def validate_async_connections(self) -> Dict[str, bool]:
        """Validate all async database connections."""
        results = {}

        # Test async database connections
        for name, config in self.databases.items():
            try:
                async_engine = create_async_engine(config.async_url, **config.get_engine_config())
                async with async_engine.begin() as conn:
                    await conn.execute(text("SELECT 1"))
                results[f"async_database_{name}"] = True
                await async_engine.dispose()
            except Exception as e:
                print(f"Async Database {name} connection failed: {e}")
                results[f"async_database_{name}"] = Falsegameplay data
- MCP Memory Store (SQLite/PostgreSQL) - AI context and memory persistence
- Redis Cache - Session storage and real-time data
- MongoDB (Optional) - Document storage for large datasets
"""

import os
from dataclasses import dataclass, field
from typing import Dict, Optional, Any, List, Union
from urllib.parse import quote_plus
from sqlalchemy import create_engine, MetaData, Engine, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncEngine
from dotenv import load_dotenv


# Load environment variables
load_dotenv()


@dataclass
class DatabaseConnectionConfig:
    """Configuration for a single database connection."""

    name: str
    host: str = "localhost"
    port: int = 5432
    database: str = ""
    username: str = "postgres"
    password: str = ""
    driver: str = "postgresql"

    # Connection pool settings
    pool_size: int = 10
    max_overflow: int = 20
    pool_timeout: int = 30
    pool_recycle: int = 3600
    pool_pre_ping: bool = True

    # Additional settings
    echo: bool = False
    echo_pool: bool = False
    sslmode: str = "prefer"
    application_name: Optional[str] = None

    # Custom URL override
    custom_url: Optional[str] = None

    def __post_init__(self):
        """Set application name if not provided."""
        if not self.application_name:
            self.application_name = f"ToolboxAI-{self.name}"

    @property
    def sync_url(self) -> str:
        """Generate synchronous database URL."""
        if self.custom_url:
            return self.custom_url

        if self.driver == "sqlite":
            return f"sqlite:///{self.database}"

        # URL encode password to handle special characters
        encoded_password = quote_plus(self.password) if self.password else ""
        password_part = f":{encoded_password}" if encoded_password else ""

        url = f"{self.driver}://{self.username}{password_part}@{self.host}:{self.port}/{self.database}"

        # Add SSL and application name parameters
        params = []
        if self.sslmode and self.driver == "postgresql":
            params.append(f"sslmode={self.sslmode}")
        if self.application_name:
            params.append(f"application_name={self.application_name}")

        if params:
            url += "?" + "&".join(params)

        return url

    @property
    def async_url(self) -> str:
        """Generate asynchronous database URL."""
        sync_url = self.sync_url

        if self.driver == "postgresql":
            return sync_url.replace("postgresql://", "postgresql+asyncpg://")
        elif self.driver == "sqlite":
            return sync_url.replace("sqlite://", "sqlite+aiosqlite://")

        return sync_url

    def get_engine_config(self) -> Dict[str, Any]:
        """Get SQLAlchemy engine configuration."""
        return {
            "pool_size": self.pool_size,
            "max_overflow": self.max_overflow,
            "pool_timeout": self.pool_timeout,
            "pool_recycle": self.pool_recycle,
            "pool_pre_ping": self.pool_pre_ping,
            "echo": self.echo,
            "echo_pool": self.echo_pool,
        }


@dataclass
class RedisConnectionConfig:
    """Configuration for Redis connection."""

    host: str = "localhost"
    port: int = 6379
    db: int = 0
    password: str = ""
    username: str = ""

    # Connection settings
    socket_timeout: float = 5.0
    socket_connect_timeout: float = 5.0
    socket_keepalive: bool = True
    socket_keepalive_options: Dict[str, int] = field(default_factory=dict)

    # Pool settings
    max_connections: int = 50
    retry_on_timeout: bool = True
    retry_on_error: List[Exception] = field(default_factory=list)
    health_check_interval: int = 30

    # Security
    ssl: bool = False
    ssl_cert_reqs: Optional[str] = None
    ssl_ca_certs: Optional[str] = None

    @property
    def url(self) -> str:
        """Generate Redis connection URL."""
        auth_part = ""
        if self.username and self.password:
            auth_part = f"{self.username}:{quote_plus(self.password)}@"
        elif self.password:
            auth_part = f":{quote_plus(self.password)}@"

        protocol = "rediss" if self.ssl else "redis"
        return f"{protocol}://{auth_part}{self.host}:{self.port}/{self.db}"


@dataclass
class MongoConnectionConfig:
    """Configuration for MongoDB connection."""

    host: str = "localhost"
    port: int = 27017
    database: str = ""
    username: str = ""
    password: str = ""

    # Connection options
    auth_source: str = "admin"
    replica_set: Optional[str] = None
    ssl: bool = False
    max_pool_size: int = 100
    min_pool_size: int = 0
    max_idle_time_ms: int = 0

    @property
    def url(self) -> str:
        """Generate MongoDB connection URL."""
        auth_part = ""
        if self.username and self.password:
            auth_part = f"{self.username}:{quote_plus(self.password)}@"

        url = f"mongodb://{auth_part}{self.host}:{self.port}/{self.database}"

        # Add connection parameters
        params = []
        if self.auth_source and auth_part:
            params.append(f"authSource={self.auth_source}")
        if self.replica_set:
            params.append(f"replicaSet={self.replica_set}")
        if self.ssl:
            params.append("ssl=true")
        if self.max_pool_size != 100:
            params.append(f"maxPoolSize={self.max_pool_size}")

        if params:
            url += "?" + "&".join(params)

        return url


class MultiDatabaseConfig:
    """Configuration manager for multiple databases."""

    def __init__(self):
        """Initialize database configurations from environment variables."""
        self.databases: Dict[str, DatabaseConnectionConfig] = {}
        self.redis: Optional[RedisConnectionConfig] = None
        self.mongodb: Optional[MongoConnectionConfig] = None
        self._load_configurations()

    def _load_configurations(self):
        """Load all database configurations from environment variables."""

        # Ghost Backend Database (Main API, Authentication, Users)
        self.databases["ghost"] = DatabaseConnectionConfig(
            name="ghost",
            host=os.getenv("GHOST_DB_HOST", "localhost"),
            port=int(os.getenv("GHOST_DB_PORT", 5432)),
            database=os.getenv("GHOST_DB_NAME", "ghost_backend"),
            username=os.getenv("GHOST_DB_USER", "ghost_user"),
            password=os.getenv("GHOST_DB_PASSWORD", ""),
            driver=os.getenv("GHOST_DB_DRIVER", "postgresql"),
            echo=os.getenv("GHOST_DB_ECHO", "false").lower() == "true",
            custom_url=os.getenv("GHOST_DATABASE_URL"),
        )

        # Educational Dashboard Database (Students, Teachers, Classes, Lessons)
        self.databases["education"] = DatabaseConnectionConfig(
            name="education",
            host=os.getenv("EDU_DB_HOST", "localhost"),
            port=int(os.getenv("EDU_DB_PORT", 5432)),
            database=os.getenv("EDU_DB_NAME", "educational_platform"),
            username=os.getenv("EDU_DB_USER", "eduplatform"),
            password=os.getenv("EDU_DB_PASSWORD", ""),
            driver=os.getenv("EDU_DB_DRIVER", "postgresql"),
            echo=os.getenv("EDU_DB_ECHO", "false").lower() == "true",
            custom_url=os.getenv("EDUCATION_DATABASE_URL"),
        )

        # Roblox Data Database (Worlds, Assets, Gameplay, Achievements)
        self.databases["roblox"] = DatabaseConnectionConfig(
            name="roblox",
            host=os.getenv("ROBLOX_DB_HOST", "localhost"),
            port=int(os.getenv("ROBLOX_DB_PORT", 5432)),
            database=os.getenv("ROBLOX_DB_NAME", "roblox_data"),
            username=os.getenv("ROBLOX_DB_USER", "roblox_user"),
            password=os.getenv("ROBLOX_DB_PASSWORD", ""),
            driver=os.getenv("ROBLOX_DB_DRIVER", "postgresql"),
            echo=os.getenv("ROBLOX_DB_ECHO", "false").lower() == "true",
            custom_url=os.getenv("ROBLOX_DATABASE_URL"),
        )

        # MCP Memory Store Database (AI Context, Memory, Vector Storage)
        self.databases["mcp"] = DatabaseConnectionConfig(
            name="mcp",
            host=os.getenv("MCP_DB_HOST", "localhost"),
            port=int(os.getenv("MCP_DB_PORT", 5432)),
            database=os.getenv("MCP_DB_NAME", "mcp_memory"),
            username=os.getenv("MCP_DB_USER", "mcp_user"),
            password=os.getenv("MCP_DB_PASSWORD", ""),
            driver=os.getenv("MCP_DB_DRIVER", "sqlite"),  # Default to SQLite for development
            echo=os.getenv("MCP_DB_ECHO", "false").lower() == "true",
            custom_url=os.getenv("MCP_DATABASE_URL"),
        )

        # Development/Test Database (Shared for development)
        self.databases["development"] = DatabaseConnectionConfig(
            name="development",
            host=os.getenv("DEV_DB_HOST", "localhost"),
            port=int(os.getenv("DEV_DB_PORT", 5432)),
            database=os.getenv("DEV_DB_NAME", "toolboxai_dev"),
            username=os.getenv("DEV_DB_USER", "postgres"),
            password=os.getenv("DEV_DB_PASSWORD", ""),
            driver=os.getenv("DEV_DB_DRIVER", "postgresql"),
            echo=os.getenv("DEV_DB_ECHO", "true").lower() == "true",
            custom_url=os.getenv("DEVELOPMENT_DATABASE_URL"),
        )

        # Redis Configuration
        if os.getenv("REDIS_HOST") or os.getenv("REDIS_URL"):
            self.redis = RedisConnectionConfig(
                host=os.getenv("REDIS_HOST", "localhost"),
                port=int(os.getenv("REDIS_PORT", 6379)),
                db=int(os.getenv("REDIS_DB", 0)),
                password=os.getenv("REDIS_PASSWORD", ""),
                username=os.getenv("REDIS_USERNAME", ""),
                ssl=os.getenv("REDIS_SSL", "false").lower() == "true",
                max_connections=int(os.getenv("REDIS_MAX_CONNECTIONS", 50)),
            )

        # MongoDB Configuration (Optional)
        if os.getenv("MONGO_HOST") or os.getenv("MONGODB_URL"):
            self.mongodb = MongoConnectionConfig(
                host=os.getenv("MONGO_HOST", "localhost"),
                port=int(os.getenv("MONGO_PORT", 27017)),
                database=os.getenv("MONGO_DATABASE", "toolboxai"),
                username=os.getenv("MONGO_USERNAME", ""),
                password=os.getenv("MONGO_PASSWORD", ""),
                auth_source=os.getenv("MONGO_AUTH_SOURCE", "admin"),
                ssl=os.getenv("MONGO_SSL", "false").lower() == "true",
            )

    def get_database_config(self, name: str) -> DatabaseConnectionConfig:
        """Get database configuration by name."""
        if name not in self.databases:
            raise ValueError(f"Database configuration '{name}' not found. Available: {list(self.databases.keys())}")
        return self.databases[name]

    def get_redis_config(self) -> RedisConnectionConfig:
        """Get Redis configuration."""
        if not self.redis:
            raise ValueError("Redis configuration not available")
        return self.redis

    def get_mongo_config(self) -> MongoConnectionConfig:
        """Get MongoDB configuration."""
        if not self.mongodb:
            raise ValueError("MongoDB configuration not available")
        return self.mongodb

    def create_engine(self, database_name: str, async_mode: bool = False) -> Union[Engine, AsyncEngine]:
        """Create SQLAlchemy engine for specified database."""
        config = self.get_database_config(database_name)
        url = config.async_url if async_mode else config.sync_url
        engine_config = config.get_engine_config()

        if async_mode:
            return create_async_engine(url, **engine_config)
        else:
            return create_engine(url, **engine_config)

    def create_sessionmaker(self, database_name: str, async_mode: bool = False):
        """Create SQLAlchemy sessionmaker for specified database."""
        config = self.get_database_config(database_name)
        url = config.async_url if async_mode else config.sync_url
        engine_config = config.get_engine_config()

        if async_mode:
            async_engine = create_async_engine(url, **engine_config)
            return async_sessionmaker(bind=async_engine, expire_on_commit=False)
        else:
            sync_engine = create_engine(url, **engine_config)
            return sessionmaker(bind=sync_engine, expire_on_commit=False)

    def validate_connections(self) -> Dict[str, bool]:
        """Validate all database connections."""
        results = {}

        # Test database connections
        for name, config in self.databases.items():
            try:
                engine = create_engine(config.sync_url, **config.get_engine_config())
                with engine.connect() as conn:
                    conn.execute(text("SELECT 1"))
                results[f"database_{name}"] = True
                engine.dispose()
            except Exception as e:
                print(f"Database {name} connection failed: {e}")
                results[f"database_{name}"] = False

        # Test Redis connection
        if self.redis:
            try:
                import redis
                client = redis.from_url(self.redis.url)
                client.ping()
                results["redis"] = True
                client.close()
            except Exception as e:
                print(f"Redis connection failed: {e}")
                results["redis"] = False

        # Test MongoDB connection
        if self.mongodb:
            try:
                import pymongo
                client = pymongo.MongoClient(self.mongodb.url)
                client.server_info()
                results["mongodb"] = True
                client.close()
            except Exception as e:
                print(f"MongoDB connection failed: {e}")
                results["mongodb"] = False

        return results

    def get_environment_template(self) -> str:
        """Generate environment variable template."""
        template = """# ============================================================================
# ToolboxAI Roblox Environment - Database Configuration
# ============================================================================

# ==================== GHOST BACKEND DATABASE ====================
# Main API, Authentication, Users, Roles, Sessions
GHOST_DB_HOST=localhost
GHOST_DB_PORT=5432
GHOST_DB_NAME=ghost_backend
GHOST_DB_USER=ghost_user
GHOST_DB_PASSWORD=your_ghost_password_here
GHOST_DB_DRIVER=postgresql
GHOST_DB_ECHO=false
# GHOST_DATABASE_URL=postgresql://ghost_user:password@localhost:5432/ghost_backend

# ==================== EDUCATIONAL DASHBOARD DATABASE ====================
# Students, Teachers, Classes, Lessons, Assessments, Progress
EDU_DB_HOST=localhost
EDU_DB_PORT=5432
EDU_DB_NAME=educational_platform
EDU_DB_USER=eduplatform
EDU_DB_PASSWORD=your_edu_password_here
EDU_DB_DRIVER=postgresql
EDU_DB_ECHO=false
# EDUCATION_DATABASE_URL=postgresql://eduplatform:password@localhost:5432/educational_platform

# ==================== ROBLOX DATA DATABASE ====================
# Worlds, Assets, Gameplay Sessions, Achievements, Avatars
ROBLOX_DB_HOST=localhost
ROBLOX_DB_PORT=5432
ROBLOX_DB_NAME=roblox_data
ROBLOX_DB_USER=roblox_user
ROBLOX_DB_PASSWORD=your_roblox_password_here
ROBLOX_DB_DRIVER=postgresql
ROBLOX_DB_ECHO=false
# ROBLOX_DATABASE_URL=postgresql://roblox_user:password@localhost:5432/roblox_data

# ==================== MCP MEMORY STORE DATABASE ====================
# AI Context, Memory, Vector Storage
MCP_DB_HOST=localhost
MCP_DB_PORT=5432
MCP_DB_NAME=mcp_memory
MCP_DB_USER=mcp_user
MCP_DB_PASSWORD=your_mcp_password_here
MCP_DB_DRIVER=sqlite  # Use SQLite for development, PostgreSQL for production
MCP_DB_ECHO=false
# MCP_DATABASE_URL=sqlite:///./mcp_memory.db

# ==================== DEVELOPMENT DATABASE ====================
# Shared development/testing database
DEV_DB_HOST=localhost
DEV_DB_PORT=5432
DEV_DB_NAME=toolboxai_dev
DEV_DB_USER=postgres
DEV_DB_PASSWORD=your_dev_password_here
DEV_DB_DRIVER=postgresql
DEV_DB_ECHO=true

# ==================== REDIS CONFIGURATION ====================
# Session storage, caching, real-time data
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=
REDIS_USERNAME=
REDIS_SSL=false
REDIS_MAX_CONNECTIONS=50
# REDIS_URL=redis://localhost:6379/0

# ==================== MONGODB CONFIGURATION (OPTIONAL) ====================
# Document storage for large datasets
# MONGO_HOST=localhost
# MONGO_PORT=27017
# MONGO_DATABASE=toolboxai
# MONGO_USERNAME=
# MONGO_PASSWORD=
# MONGO_AUTH_SOURCE=admin
# MONGO_SSL=false
# MONGODB_URL=mongodb://localhost:27017/toolboxai

# ==================== CONNECTION POOL SETTINGS ====================
# Global connection pool settings (optional overrides)
DB_POOL_SIZE=10
DB_MAX_OVERFLOW=20
DB_POOL_TIMEOUT=30
DB_POOL_RECYCLE=3600

# ==================== ENVIRONMENT SETTINGS ====================
ENVIRONMENT=development
DEBUG=true
"""
        return template


# Global configuration instance
db_config = MultiDatabaseConfig()


# Convenience functions
def get_database_config(name: str) -> DatabaseConnectionConfig:
    """Get database configuration by name."""
    return db_config.get_database_config(name)


def get_redis_config() -> RedisConnectionConfig:
    """Get Redis configuration."""
    return db_config.get_redis_config()


def get_mongo_config() -> MongoConnectionConfig:
    """Get MongoDB configuration."""
    return db_config.get_mongo_config()


def create_engine(database_name: str, async_mode: bool = False):
    """Create SQLAlchemy engine for specified database."""
    return db_config.create_engine(database_name, async_mode)


def create_sessionmaker(database_name: str, async_mode: bool = False):
    """Create SQLAlchemy sessionmaker for specified database."""
    return db_config.create_sessionmaker(database_name, async_mode)


def validate_all_connections() -> Dict[str, bool]:
    """Validate all database connections."""
    return db_config.validate_connections()


if __name__ == "__main__":
    # Test configuration and connections
    print("ToolboxAI Database Configuration")
    print("=" * 50)

    # Print available databases
    print(f"Available databases: {list(db_config.databases.keys())}")

    # Print connection URLs (without passwords)
    for name, config in db_config.databases.items():
        url = config.sync_url
        # Mask password in output
        if ":" in url and "@" in url:
            parts = url.split(":")
            if len(parts) >= 3:
                masked_url = f"{parts[0]}:{parts[1]}:***@{':'.join(parts[3:])}"
            else:
                masked_url = url
        else:
            masked_url = url
        print(f"{name}: {masked_url}")

    # Validate connections
    print("\nTesting connections...")
    results = validate_all_connections()
    for service, status in results.items():
        status_icon = "✅" if status else "❌"
        print(f"{status_icon} {service}: {'Connected' if status else 'Failed'}")

    print("\nEnvironment template:")
    print(db_config.get_environment_template())
